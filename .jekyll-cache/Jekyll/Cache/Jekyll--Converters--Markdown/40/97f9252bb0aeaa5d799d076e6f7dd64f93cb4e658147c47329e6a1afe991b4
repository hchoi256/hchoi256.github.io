I"yL<p>PCA를 이용해서 이미지 압축을 진행해보자.</p>

<h1 id="code">Code</h1>
<p class="notice--danger"><strong>[Notice]</strong> <a href="https://github.com/hchoi256/cs540-AI/tree/main/PCA">download here</a></p>

<p>이번 프로젝트는 <strong>PCA</strong>를 활용해서 <strong>이미지 압축</strong> 문제를 해결한다.</p>

<p>이론적으로 PCA의 개념을 이해하고 있다는 전제로 프로젝트를 수행한다.</p>

<blockquote>
  <p><a href="https://github.com/hchoi256/ai-terms/blob/main/README.md">PCA</a> 개념 숙지는 여기!</p>
</blockquote>

<h1 id="데이터-불러오기">데이터 불러오기</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">load_and_center_dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">dc</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 정규화
</span>    <span class="k">return</span> <span class="n">dc</span>
</code></pre></div></div>

<h1 id="공분산-행렬-구하기">공분산 행렬 구하기</h1>

<p><img src="https://user-images.githubusercontent.com/39285147/184553498-b0da1938-a6d9-4ad1-b8f9-8c127c7cfbe7.png" alt="image" /></p>

<p><strong>공분산</strong>은 <strong>데이터 분포에 대한 특징</strong>을 포함하는 행렬이다.</p>

<blockquote>
  <p>보다 자세한 정보는 <a href="https://github.com/hchoi256/ai-terms/blob/main/README.md">여기</a>를 참조하자.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_covariance</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span> <span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="고유값-분해eigendecomposition">고유값 분해(Eigendecomposition)</h1>

<p>고유값 분해는 정방행렬을 대상으로 적용할 수 있는 기법이다.</p>

<p>만약 우리가 다루는 행렬이 <strong>정방행렬</strong>이 아닌 <strong>직각행렬</strong>이라면 고유값 분해대신 <strong>특이값 분해(singular value decomposition)</strong>를 사용하면 된다.</p>

<blockquote>
  <p>이 또한 보다 자세한 정보는 <a href="https://github.com/hchoi256/ai-terms/blob/main/README.md">여기</a>를 참조하자.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_eig</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">subset_by_index</span><span class="o">=</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># get largest m eigen-values/vectors
</span>    <span class="n">eigh_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">eigh_dict</span><span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="c1"># save columns of eigenvectors
</span>    <span class="n">wsrt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">w</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># eigenvalues in decreasing order
</span>    <span class="n">vsrt</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">vsrt</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigh_dict</span><span class="p">[</span><span class="n">wsrt</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="c1"># rearrangement
</span>    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">wsrt</span><span class="p">),</span> <span class="n">vsrt</span>
</code></pre></div></div>

<p>파이썬에서는 ‘<em>scipy.linalg import eigh</em>‘를 활용해서 손쉽게 고유값 분해를 처리할 수 있다.</p>

<p>해당 라이브러리의 ‘eigh’ 함수를 통해 고유값과 고유벡터를 얻을 수 있다.</p>
<ul>
  <li>‘<em>subset_by_index</em>’: 불러오는 고유값과 고유벡터 수를 지정한다.</li>
</ul>

<p>공분산 행렬에 고유값 분해를 취하여 얻는 고유벡터들 중에서 <strong>그 크기가 가장 큰 벡터들은 데이터 분포에서 분산을 가장 크게 만드는 축에 대한 주성분 벡터</strong>이다.</p>

<p>차원축소 과정에서, 분산을 가장 크게 만드는 주성분들 위로 데이터를 투영시키면, 차원이 줄어듦에 따라 소실되면 정보를 최소화할 수 있다.</p>

<blockquote>
  <p>보다 자세한 정보는 <a href="https://github.com/hchoi256/ai-terms/blob/main/README.md">여기</a>를 참조하자.</p>
</blockquote>

<p>따라서, 우리는 m(압축하고자 하는 이미지 차원 개수)개의 고유벡터를 가져와서 축소를 진행한다.</p>

<p>‘get_eig’의 출력값은 각 고유벡터의 <strong>크기가 큰 순서로</strong> 고유값을 정렬한 대각행렬과 이에 상응하는 고유벡터를 return한다.</p>

<p>추가적으로, 하기 ‘get_eig_prop’는 압축하고자 하는 이미지 해상도 크기를 입력으로 받는 것이 아닌 <strong>어느 정도 비율로 이미지를 압축할 것인지</strong>를 인풋으로 받는 함수이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_eig_prop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">perc</span><span class="p">):</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">wsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">subset_by_value</span><span class="o">=</span><span class="p">[</span><span class="n">perc</span> <span class="o">*</span> <span class="n">wsum</span><span class="p">,</span> <span class="n">wsum</span><span class="p">])</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">eigh_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">eigh_dict</span><span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
    <span class="n">wsrt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">w</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># eigenvalues in decreasing order
</span>    <span class="n">vsrt</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">vsrt</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigh_dict</span><span class="p">[</span><span class="n">wsrt</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="c1"># rearrangement
</span>    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">wsrt</span><span class="p">),</span> <span class="n">vsrt</span>
</code></pre></div></div>

<h1 id="차원축소-투영projection">차원축소: 투영(projection)</h1>

<p>위에서 투영시켜야할 축들을 구해냈으니, 실질적으로 데이터를 그 축들에 투영시키면서 차원을 축소해보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">project_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">U</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># img.shape: (1024,)
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># U.shape: (1024, 2)
</span>        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">img</span><span class="p">)</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">U</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">sum</span>
</code></pre></div></div>

<p>‘np.zeros(img.shape[0])’는 원본 이미지의 크기만큼의 배열을 생성하고, 그 값들은 전부 0으로 초기화한다.</p>

<p>‘U.shape[1]’는 우리가 투영시킬 차원(= 주성분)들에 대한 벡터의 개수이다.</p>
<ul>
  <li>‘U.shape[0]’는 원본 이미지의 해상도인 1024(32x32)의 값을 갖는다.</li>
</ul>

<p>[<em>투영(Projection) 공식</em>]</p>

<p><img src="https://user-images.githubusercontent.com/39285147/184554057-7c2d4211-c7af-4c22-8e5d-37f157b54a48.png" alt="image" />
<img src="https://user-images.githubusercontent.com/39285147/184554076-25f700e4-e27f-4286-94dd-7254505d4f4b.png" alt="image" /></p>

<ul>
  <li>u들은 고유벡터들 말한다.</li>
  <li>x들은 원본 이미지 데이터이다.</li>
  <li>m: 투영시킬 차원 개수(= 최종 해상도 크기)</li>
</ul>

<h1 id="시각화-원본-이미지와-비교">시각화: 원본 이미지와 비교</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">display_image</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">proj</span><span class="p">):</span>
    <span class="c1"># reshape the images to be 32 x 32
</span>    <span class="n">org</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s">'F'</span><span class="p">)</span>
    <span class="n">prj</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s">'F'</span><span class="p">)</span>
    <span class="c1"># create a figure with one row of two subplots
</span>    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># title the subplots
</span>    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Original'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Projection'</span><span class="p">)</span>
    <span class="c1"># adjust aspect ratio
</span>    <span class="n">ax0</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">imshow</span><span class="p">(</span><span class="n">org</span><span class="p">,</span><span class="n">aspect</span> <span class="o">=</span> <span class="s">'equal'</span><span class="p">)</span>
    <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">imshow</span><span class="p">(</span><span class="n">prj</span><span class="p">,</span><span class="n">aspect</span> <span class="o">=</span> <span class="s">'equal'</span><span class="p">)</span>
    <span class="c1"># create a colorbar for each image
</span>    <span class="n">fig</span><span class="p">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">fig</span><span class="p">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h1 id="결과">결과</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">load_and_center_dataset</span><span class="p">(</span><span class="s">'&lt;이미지 파일&gt;.npy'</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">get_covariance</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">Lambda</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">get_eig</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">projection</span> <span class="o">=</span> <span class="n">project_image</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">U</span><span class="p">)</span>
<span class="n">display_image</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">projection</span><span class="p">)</span>
</code></pre></div></div>

<p>상기 코드를 통해 손쉽게 원본 이미지와 압축된 이미지를 비교해보자.</p>

<p><img src="https://user-images.githubusercontent.com/39285147/184554368-15a426d7-fd5c-4838-97d6-2b13b820149c.png" alt="image" /></p>
:ET