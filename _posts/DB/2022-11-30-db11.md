---
layout: single
title: "DBMS: Evaluation of Relational Operations"
categories: DB
tag: [Database, External Sorting, Relational Operations]
toc: true
toc_sticky: true
toc_label: "ì­ŒìŠ¤log"
#author_profile: false
header:
    teaser: /assets/images/posts/db.png
sidebar:
    nav: "docs"
---

# INTRO ğŸ™Œ
ì €ë²ˆ ì‹œê°„ì—ëŠ” Sorting & Relational Operations ì— ëŒ€í•˜ì—¬ ì•Œì•„ë³´ì•˜ë‹¤.

ì´ë²ˆ ì‹œê°„ì—ëŠ” **Evaluation of Relational Operations: Other Techniques**ì— ëŒ€í•´ ì•Œì•„ë³´ì.

****
# Selection Operation (Simple Selection)
- Select (R.attr `<op>` value) R (i.e., $$age = 20$$).

## No index, unsorted (file scan)
- must scan whole table

## No Index, Sorted Data (sorted-file scan)
> ê¸°ë§ ì¶œì œ X

$$O(log_2M)+(scan\ cost)$$

- utilize the sort order through a binary search ($$O(log_2M)$$).
    - locate the first tuple that satisfies the selection condition
    - retrieve all tuples that satisfy the selection condition by scanning R until the selection condition is no longer satisfied.
- í•œê³„:
    - í˜„ì‹¤ì—ì„œ ì •ë ¬ëœ ë°ì´í„° ë³´ì¥ X
- í•´ê²°:
    - `Alternative (1`):
        - allow data records to be stored as index data entries.
    - If the ordering of data records is important $$\rightarrow$$ B+ tree index that uses `Alternative (1)`.

## B+ Tree Index
- `STEP 1`: locate the first index entry that points to a qualifying tuple of R
    - Cost: 2 or 3 I/Os
- `STEP 2`: Scan the leaf pages to retrieve all entries in which the key value satisfies the selection condition
    - Cost: Depends on the number of qualifying tuples, the employed alternative and whether the index is clustered

ê¸°ì¡´ indexë³´ë‹¤ ë” ì¢‹ì€ ì„±ëŠ¥ì˜ index êµ¬í˜„ ê°€ëŠ¥í•˜ë‹¤.
- ê¸°ì¡´ index: íŒŒì¼ì´ ì»¤ì§ˆìˆ˜ë¡ ë§ì€ **overflow block** ë°œìƒ $$\rightarrow$$ ì„±ëŠ¥ í•˜ë½ $$\rightarrow$$ ì£¼ê¸°ì  ì¬êµ¬ì„±í•  í•„ìš”
- B+ Tree: ì‚½ì…/ì‚­ì œ ì‹œ ìë™ìœ¼ë¡œ êµ¬ì¡° ìœ ì§€ $$\rightarrow$$ ì£¼ê¸°ì  ì¬êµ¬ì„±í•  í•„ìš” X.

> B+ Tree Index ê¸°ë§ì—ì„œ ì´ê²ƒë§Œ ì•Œë©´ ë¨
>
>> Btree: good for $$>=, <=$$

## Hash Index (Best)
- hashingì„ í†µí•´ ë°ì´í„° ìœ„ì¹˜ index ì €ì¥
    - hashing í•¨ìˆ˜ = key ê°’ì„ ì¼ì •í•œ ë²”ìœ„ì˜ ìˆ˜ë¡œ ë³€í™˜
- Cost = a few (typically one or two) l/Os

> Hash Index ê¸°ë§ì—ì„œ ì´ê²ƒë§Œ ì•Œë©´ ë¨
>
>> hash: good for $$=$$

****
# Projection Operation ğŸœ
            SELECT DISTINCT R.sid, R.bid
            FROM Reserves R

## 1) Sort-based Projection
An approach based on sorting:
1. Pass 0 (external sort): **eliminate unwanted fields**.  
2. **Eliminate duplicates**.  

0. only need `sid` and `bid`
1. external sorting
2. *Pass 0*: remove unwanted fields (except for `sid` and `bid`).
3. if duplicates in merging $$\rightarrow$$ discard them

## 2) Hash-based Projection
0. only need `sid` and `bid`
1. external sorting
2. $$h1()$$: generate $$B-1$$ partitions (each partition = small enough to fit in memory)
3. remove unwatned fields
4. $$h2\ (<>\ h1)$$ (if partition is still too big $$\rightarrow$$ go to 2 (recursive)).
5. remove duplicates in each partition (duplicates already in the hash table); ì„œë¡œ ë‹¤ë¥¸ partition ê°„ duplicate ì¡´ì¬ X (hashing ê±°ì³¤ê¸° ë•Œë¬¸)
6. write out all tuples in the hash table $$\rightarrow$$ no duplicates

> **Purpose of Hash table** : keep track of which tuple is on focus

****
# Set Operations ğŸ˜
## Intersection and cross-product
- Special cases of join.

## Union (Distinct) and Except
- **Union** $$\Leftrightarrow$$ Except.
- removes duplicates within the same partition
    - put in memory (hash table)
    - if already exist $$\rightarrow$$ duplicates.

### Sorting based approach to union:
            SELECT DISTINCT R.sid, R.bid
            FROM Reserves R

- Sort both relations (on combination of all attributes).
- Scan sorted relations and merge them.
- *Alternative*:  Merge runs from Pass 0 for both relations.

### Hash based approach to union:
- Partition $$R$$ and $$S$$ using hash function $$h()$$.
- For each S-partition:
    - build in-memory hash table (using h2)
    - scan corresponding R-partition
    - add tuples to table while discarding duplicates.

> ê¸°ë§ì¶œì œ!! â˜…â˜…â˜…â˜…â˜…â˜…
>
>> Sort-based intersection to union ì–´ë–»ê²Œ í•´?
>>
>> Hash-based intersection to union ì–´ë–»ê²Œ í•´?

****
# Aggregate Operations (AVG, MIN, etc.) ğŸ¥š
- Expensive!! ($$\larr$$ must touch all tuples)

> **index-only scan**:
>
>> SELECT ì¹¼ëŸ¼ ë° WHERE ì¡°ê±´ì„ ëª¨ë‘ í¬í•¨í•˜ëŠ” ì¸ë±ìŠ¤ ê¸°ì¤€ scan; avoid looking at the table data entirely

## Without grouping:
        SELECT max(sal)
        FROM Emp

- In general, **requires scanning the whole relation**.
- Given index whose search key includes all attributes in the $$SELECT$$ or $$WHERE$$ clauses, can do **index-only scan**.

## With grouping:
        SELECT max(sal), qty
        FROM Emp
        GROUP BY qty

- **Sort on group-by attributes**, then scan relation and compute aggregate for each group.
    - Can improve upon this by combining sorting and aggregate computation
        - Sorting ê³¼ì •ì—ì„œ *mean* ê°™ì€ ìˆ˜ì¹˜ êµ¬í•  ìˆ˜ ìˆìŒ.
- Similar approach based on **hashing on group-by attributes**.
- Given **tree index** whose search key includes all attributes in $$SELECT$$, $$WHERE$$ and $$GROUP\ BY$$ clauses, can do **index-only scan**
    - if group-by attributes form prefix of search key, can retrieve data entries/tuples in group-by order.

****
# Summary ğŸ‘Œ
- A virtue of relational DBMSs:
    - **queries are composed of a few basic operators**; the implementation of these operators can be carefully tuned (and it is important to do this!).
- Many alternative implementation techniques for each operator
    - no universally superior technique for most operators.  
- Must consider available alternatives for each operation in a query and choose best one based on system statistics, etc.
    - This is part of the broader task of optimizing a query composed of several ops. 

****
# Reference 
[Database Management Systems by Raghu Ramakrishnan and Johannes Gehrke](https://pages.cs.wisc.edu/~dbbook/)

[Relational Operators](https://www.javatpoint.com/dbms-relational-algebra)