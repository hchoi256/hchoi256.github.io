---
layout: single
title: "DBMS(데이터베이스 관리 시스템)"
categories: DB
tag: [Database, DBMS, ER Model]
toc: true
toc_sticky: true
toc_label: "쭌스log"
#author_profile: false
header:
    teaser: /assets/images/posts/db.png
sidebar:
    nav: "docs"
---

# DBMS (Databse Management System) 개요
[*Structure of DBMS*]

![image](https://user-images.githubusercontent.com/39285147/189471863-c45396bc-de4b-4fae-8af8-2dc700bc4c69.png)

A very large, integrated collection of data; software package designed to store and manage databses.
- Entities (e.g., students)
- Relationships (e.g., Eric is taking the class)

A DBMS typically has a *layered architecture*.
- 각 계층은 Application에서 특정 역할별로 구분된다("Separation of Concern") --> 유지보수성 ↑, 테스트 난이도 ↓

## Benefits
- Recovery from system crashes
- Concurrent access
- Quick application development
- Data integrity and security.

## Data model
![image](https://user-images.githubusercontent.com/39285147/192067169-83a3dbb2-9b6c-4e41-b856-2011dd222530.png)

A collection of concepts for describing data; 데이터들의 구조도를 그리는 과정

Data model으로는 **Relational model of data**가 가장 많이 사용된다.
- *Relation*: a table with rows and columns.
- Every relation has a *schema*.

## Schema
A description of a particular collection of data, using the given data model.

### Level of Abstraction
![image](https://user-images.githubusercontent.com/39285147/189469124-efd0da27-2542-4b63-b30c-e579c268c36b.png)

**Conceptual Schema**(개념적 데이터 모델링): define logical structure; 데이터들의 구조도를 그리는 과정 (*ER Model* 사용 多)
- i.e., Students(sid: string, name: string, login: string, age: integer, gpa: real)

**Logical Shcema**(논리적 데이터 모델링): 데이터 모델(e.g., ER Model)을 선택하고 데이터 스키마를 결정하는 과정

**Physical Schema**(물리적 데이터 모델링): 논리적 데이터 모델링에서 선택한 데이터베이스 모델(e.g., MySQL)에 따라 물리적인 데이터베이스를 만들어내는 과정

> 한줄요약: ER Model을 이용하여 필요한 데이터들의 구조도를 그리고, 관계 데이터베이스 모델에 따라 스키마를 결정하고, 데이터베이스를 구축한다.

> [Schema are defined using DDL(데이터 정의어); data is modified using DML(데이터 조작어)](https://brownbears.tistory.com/180)

## DB Application 설계 과정
**Step 0**: pick an application domain

**Step 1**: conceptual design (**Conceptual Schema**)
- discuss what to model in the application domain
- need a modeling language to express what you want
    - ER model is the most popular such language
- *output*: an ER diagram of the app. domain

**Step 2**: pick a type of DBMS
- relational DBMS is most popular and is our focus

**Step 3**: translate ER design to a relational schema (**Logical Shcema**)
- use a set of rules to translate from ER to rel. schema
- use a set of schema refinement rules to transform the above rel. schema into a good rel. schema

**Step 4**: **Physical Schema**
- implement your relational DBMS using a "database programming language" called SQL
- ordinary users cannot interact with the database directly
- and the database also cannot do everything you want
- hence write your application program in C++, Java, Python, etc to handle the interaction and take care of things that the database cannot do

# DBMS 설계 개요
## Data Independence
**Logical data independence**: protected from changes in *logical* structure of data

**Physical data independence**: protected from changes in *physical* structure of data

## Concurrency Control (동시성)
Disk accesses are frequent and relatively slow --> important to keep the cpu humming by working on several user programs concurrently.

In DBMS, users can pretend they are using a **single-user system**
- **Transaction**: atomic sequence of database actions (reads/writes)
    - On each transaction, the DB is in a *consistent state* (user's responsibility!)

> *Integrity constraints*(무결성 제약조건): 데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건이다.

## Atomicity
DBMS ensures *atomicity*(all-or-nothing property) even if system crashes in the middle of a Xact
- **log(history)** of all actions
    - Log는 Xact id와 연계되어 있어서, undo 처리가 수월하다 (i.e., to resolve deadlock)
        - i.e., 충돌 --> 작업 초기화(원래 작업 log로 되돌아감)
    - duplexed and archived on "*stable*" storage
    - handled *transparently* by the DBMS
    - i.e., *write*(log before the changed page), *commit/abort*
- 만약 log 저장하기 전 충돌 발생한다면?
    - **WAL protocol**: log 저장하기 전 충돌발생해도 DB에 변경사항 아직 저장 안시킴

# Conceptual Design Model: ER Model
![image](https://user-images.githubusercontent.com/39285147/192067549-5b9439d1-280c-482c-a32f-8e59b304e892.png)

ER Model Gives us a language to specify
- what information the db must hold
- what are the relationships among components of that information

*Conceptual design* 단계에서 사용되는 모델링 기법으로, 주관적인 디자인 때문에 주어진 시나리오가 다양한 모델로 표현될 수 있다.

그 중에서도, 좋은 DB 디자인을 구현하기 위하여 관계 스키마([Relational schema](#data-model))를 분석할 필요가 있다.
- **FD information** and **normalization techniques** are especially useful in such analysis.

![image](https://user-images.githubusercontent.com/39285147/190265629-f75d18ae-e351-4260-abf2-4d752e6c35ef.png)

**Entity**: 하나의 객체/튜플; real-world object distinguishable from other objects; described using a set of attributes

**Attributes**: each has an atomic domain: string, integers, reals, etc.

**Relations**: if A, B are sets, then a relation R is a subset of A x B

![image](https://user-images.githubusercontent.com/39285147/192067416-e23ceac9-8206-4baf-ad5e-07a4967e2061.png)

- A={1,2,3}, B={a,b,c,d}; R = {(1,a), (1,c), (3,b)}

**Entity Set**: 같은 테이블의 있는 튜플들의 집합; a collection of similar entities (i.e., all employees)
- All entities in an entity set have the same set of attributes (unless *ISA hierarchies*)
- Each entity set has a *key*
- Each attribute has a *domain*

[*An entity set (Person) twice in one relationship*]

![image](https://user-images.githubusercontent.com/39285147/192068721-d1e373be-0aa8-4c30-aa15-788628cd1f3e.png)

**Relationship**: Entity Set 간의 관계; Association among two or more entities (i.e., Eric works in department) ![image](https://user-images.githubusercontent.com/39285147/190265838-c0e74074-7fc4-4431-80ae-dbce6427038f.png)

[*Attributes on Relationships*]

![image](https://user-images.githubusercontent.com/39285147/192068774-af839179-df9d-4372-b97a-3b7990f16bee.png)

[*Multiway Relationship*]

![image](https://user-images.githubusercontent.com/39285147/192068482-98cc5f8c-3146-4ea0-8795-4b7afca9b22a.png)

**Relationship Set**: collection of similar relationships ![image](https://user-images.githubusercontent.com/39285147/190265963-49190735-6cf5-42c9-be6e-106c8a68ad06.png)

- store, person, invoice **determines** movie
- store, invoice, movie **determines** person

## 무결성 제약조건(Constraints)
Constraints play an important role in determining the best database design for an enterprise.

### **Key Constraints**
![image](https://user-images.githubusercontent.com/39285147/190267915-76f88356-ec2a-4987-b557-0af9e0cbe4ea.png)

![image](https://user-images.githubusercontent.com/39285147/192067706-42de1ff9-f0a7-4687-8572-877a5d91b302.png)
![image](https://user-images.githubusercontent.com/39285147/192068599-a84b5679-8ba4-47c8-91e8-d12babab5044.png)

### **Participation Constraints**
![image](https://user-images.githubusercontent.com/39285147/190268223-556df41a-fee7-42d7-99f1-7010a4f0e2a7.png)

관계를 맺는 두 Entity Type에 대해 한 개체의 존재가 다른 개체의 존재에 **의존하는지 여부**를 나타내는 제약조건으로, 하나 또는 그 이상의 개체가 참여한다.
- 가령, 직원은 여러 회사에서 무조건 일하지 않아도 괜찮으나, 회사는 직원이 무조건 있어야 한다 (전체 참여: *Total*)

The participation of Departments in Manages is said to be *total* (vs. *partial*)
- Every *did* value in Departments table must appear in a row of the Manages table (여기서 SSN은 null이 아니다).

For example, every department has a manager.

### **Overlap Constraints(중첩 제약조건)**
다수 하위클래스 속할 수 있는지; Can Joe be an Hourly_Emps as well as a Contrat_Emps entity? (Allowed/disallowed)

### **Covering Constraints(포괄 제약조건)**
적어도 하나 하위 클래스에 속해야하는 지; Does every Employees entity also have to be an Hourly_Emps or a Contract_Emps entity? (Y/N)

### **Foreign key constraints(외래키 제약조건)**
두 테이블 사이의 관계를 선언함으로써, 데이터의 **무결성**을 보장해 주는 역할을 한다.

외래 키 관계를 설정하게 되면 하나의 테이블(외래 키 테이블)이 다른 테이블(기준 테이블)에 **의존**하게 된다.

'외래 키 테이블'에 데이터를 입력할 때는 꼭 '기준 테이블'을 참조해서 입력하므로, 반드시 **'기준 테이블'에 존재하는 데이터만** 입력이 가능하다.

> Some constraints (i.e., *functional dependencies*) cannot be expressed in the ER model.

## Conceptural Design 구조
> 많은 데이터 구문(data semantics)이 사용되지만, 몇몇은 ER Diagram에서 사용될 수 없다.

1. **Weak Entities(약한 개체)**

![image](https://user-images.githubusercontent.com/39285147/190269229-1244c261-73b5-4c6f-9822-8b0a01c7f13a.png)

**Weak entity**: 자신의 key attribute가 없는 entity type (i.e., 어떤 강의에서 분반은 자신의 key attribute이 없고 강의 테이블에 의존한다); can be identified uniquely only by considering the primary key of another (owner) entity
- *one-to-many relationship* (one: owner)
- *total participation*

2. **ISA('is a') Hierarchies**

![image](https://user-images.githubusercontent.com/39285147/190352208-83269070-2ff3-4dad-b08f-67192bac72f5.png)

- *A ISA B*: every A entity is also considered to be a B entity.
- 상위클래스(Superclass)-하위클래스(Subclass)의 관계이다.

![image](https://user-images.githubusercontent.com/39285147/190271387-65436bb6-6b10-4d37-bdc7-cb5b214230b0.png)

- **Overlap Constraints(중첩 제약조건)**
- **Covering Constraints(포괄 제약조건)**

3. **Aggregation(집단화)**

![image](https://user-images.githubusercontent.com/39285147/190845788-27bce39b-b1a9-4048-815d-2f1a692b2400.png)

- *수강*: a distinct relationship with a descriptive attribute
- *강의*: 각 수업은 하나의 학생이 존재해야 교수가 강의할 수 있다.

Used when we have to model a relationship involving (entity sets and) a relationship set
- Treat a relationship set as an entity set for purposes of participation in other relationships

쉽게 말해, Entity - Relationship Set 간의 관계로, Entity만으로 특정 상황을 명확히 표현하기 어려울 때 Aggregation을 사용한다.

## Conceptual Design Using the ER Model
1. **개체-속성 선택**

![image](https://user-images.githubusercontent.com/39285147/190846370-5d500dfb-9e8a-40a5-a9c3-abdfb057deb5.png)

상기 모형에서, Works_In2는 한 직원이 어느 부서애서 2달 이상의 "기간" 동안 일하는 것을 허용하지 않는 에로사항이 존재한다.
- "기간"이 아니라 "일자"를 입력해야 한다.

![image](https://user-images.githubusercontent.com/39285147/190846381-6ea46770-80ee-4347-82ba-21b0697a984f.png)

기간으로도 입력을 받기 위하여, Duration이라는 개체에 속한 속성으로 *from, to*를 primary keys로 등록한다.

따라서, 어떠한 정보를 개체에 속한 속성으로 만들지, 따로 하나의 개체로 만들지 상황에 맞게 선택해야 한다.

2. **개체-관계 선택**

![image](https://user-images.githubusercontent.com/39285147/190846469-7a94e94c-497d-480e-b6d2-e0ec9371f5b0.png)

어떠한 속성을 관계의 속성으로 만들지 (i.e., a manager gets a separate discretionary budget for each dept.)

![image](https://user-images.githubusercontent.com/39285147/190846452-e7140ba8-502e-461e-9278-d79670089833.png)

개체의 속성으로 만들지 상황에 맞게 선택해야 한다 (i.e., a manager gets a separate discretionary budget that covers all managed depts)

3. **이진관계(binary)-삼진관계(ternary) 선택**

[*이진관계*]

![image](https://user-images.githubusercontent.com/39285147/190846526-4c83da45-9512-4b37-a032-98fc28fd8e6d.png)

[*삼진관계*]

![image](https://user-images.githubusercontent.com/39285147/190846512-a945f517-6036-428a-b779-9ad499b6ef87.png)

상황에 맞는 이진관계 혹은 삼진관계를 선택해야 한다.

삼진관계 모형에는 하나의 에로사항이 있다.

만약 Employee마다 오로지 한 개의 Policy만 행사하는 경우, 각각 **한 명의 Dependent만** Cover 가능할 것이다.

그렇다면, 여기서 이상적인 상황은 Employee마다 여러 개의 Policies를 활용해 여러 명의 Dependents를 Cover하는 상황일 것이다.

이 에로사항을 타파하기 위하여 이진관계를 사용해 Purchaser()

상기 예시에서는 두 개의 이진관계가 하나의 삼진관계보다 더 효과적으로 동작하는 것을 보여준다.

> 삼진관계를 이진관계들로 표현할 때 값이 달라질 수 있어서, weak entity를 사용해 식별 관계로 바꿔주는 것이 안전하다.

반대로, 가령 삼항 관계 'Contracts'는 엔티티 세트 'Parts', 'Departments' 및 'Supplier'와 관련되며 설명 속성 'qty'를 가질 때, 이진 관계의 어떤 조합도 적절한 대안이 될 수 없을 것이다.

# Reference
[ER Model](https://magician-of-c.tistory.com/49)
