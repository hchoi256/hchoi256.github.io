---
layout: single
title: "DBMS(데이터베이스 관리 시스템)"
categories: DB
tag: [Database, DBMS, ER Model]
toc: true
toc_sticky: true
toc_label: "쭌스log"
#author_profile: false
header:
    teaser: /assets/images/posts/db.png
sidebar:
    nav: "docs"
---

# DBMS (Databse Management System)
[*Structure of DBMS*]

![image](https://user-images.githubusercontent.com/39285147/189471863-c45396bc-de4b-4fae-8af8-2dc700bc4c69.png)

A very large, integrated collection of data; software package designed to store and manage databses.
- Entities (e.g., students)
- Relationships (e.g., Eric is taking the class)

A DBMS typically has a *layered architecture*.
- 각 계층은 Application에서 특정 역할별로 구분된다("Separation of Concern") --> 유지보수성 ↑, 테스트 난이도 ↓

**Benefits**
- Recovery from system crashes
- Concurrent access
- Quick application development
- Data integrity and security.

## Data model
A collection of concepts for describing data; 데이터들의 구조도를 그리는 과정

Data model으로는 **Relational model of data**가 가장 많이 사용된다.
- *Relation*: a table with rows and columns.
- Every relation has a *schema*.

## Schema
A description of a particular collection of data, using the given data model.

### Level of Abstraction
![image](https://user-images.githubusercontent.com/39285147/189469124-efd0da27-2542-4b63-b30c-e579c268c36b.png)

**Conceptual Schema**(개념적 데이터 모델링): define logical structure; 데이터들의 구조도를 그리는 과정 (*ER Model* 사용 多)
- i.e., Students(sid: string, name: string, login: string, age: integer, gpa: real)

**Logical Shcema**(논리적 데이터 모델링): 데이터 모델(e.g., ER Model)을 선택하고 데이터 스키마를 결정하는 과정

**Physical Schema**(물리적 데이터 모델링): 논리적 데이터 모델링에서 선택한 데이터베이스 모델(e.g., MySQL)에 따라 물리적인 데이터베이스를 만들어내는 과정

> 한줄요약: ER Model을 이용하여 필요한 데이터들의 구조도를 그리고, 관계 데이터베이스 모델에 따라 스키마를 결정하고, 데이터베이스를 구축한다.

> [Schema are defined using DDL(데이터 정의어); data is modified using DML(데이터 조작어)](https://brownbears.tistory.com/180)

# DBMS 특성
## Data Independence
**Logical data independence**: protected from changes in *logical* structure of data

**Physical data independence**: protected from changes in *physical* structure of data

## Concurrency Control (동시성)
Disk accesses are frequent and relatively slow --> important to keep the cpu humming by working on several user programs concurrently.

In DBMS, users can pretend they are using a **single-user system**
- **Transaction**: atomic sequence of database actions (reads/writes)
    - On each transaction, the DB is in a *consistent state* (user's responsibility!)

> *Integrity constraints*(무결성 제약조건): 데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건이다.

### Atomicity
DBMS ensures *atomicity*(all-or-nothing property) even if system crashes in the middle of a Xact
- **log(history)** of all actions
    - Log는 Xact id와 연계되어 있어서, undo 처리가 수월하다 (i.e., to resolve deadlock)
        - i.e., 충돌 --> 작업 초기화(원래 작업 log로 되돌아감)
    - duplexed and archived on "*stable*" storage
    - handled *transparently* by the DBMS
    - i.e., *write*(log before the changed page), *commit/abort*
- 만약 log 저장하기 전 충돌 발생한다면?
    - **WAL protocol**: log 저장하기 전 충돌발생해도 DB에 변경사항 아직 저장 안시킴

# ER Model
*Conceptual design* 단계에서 사용되는 모델링 기법이다.

![image](https://user-images.githubusercontent.com/39285147/190265629-f75d18ae-e351-4260-abf2-4d752e6c35ef.png)

**Entity**: 하나의 객체/튜플; real-world object distinguishable from other objects; described using a set of attributes

**Entity Set**: 같은 테이블의 있는 튜플들의 집합; a collection of similar entities (i.e., all employees)
- All entities in an entity set have the same set of attributes (unless *ISA hierarchies*)
- Each entity set has a *key*
- Each attribute has a *domain*

**Relationship**: Entity Set 간의 관계; Association among two or more entities (i.e., Eric works in department) ![image](https://user-images.githubusercontent.com/39285147/190265838-c0e74074-7fc4-4431-80ae-dbce6427038f.png)

**Relationship Set**: collection of similar relationships ![image](https://user-images.githubusercontent.com/39285147/190265963-49190735-6cf5-42c9-be6e-106c8a68ad06.png)

## Key Constraints
![image](https://user-images.githubusercontent.com/39285147/190267915-76f88356-ec2a-4987-b557-0af9e0cbe4ea.png)

## Participation Constraints
![image](https://user-images.githubusercontent.com/39285147/190268223-556df41a-fee7-42d7-99f1-7010a4f0e2a7.png)

관계를 맺는 두 Entity Type에 대해 한 개체의 존재가 다른 개체의 존재에 **의존하는지 여부**를 나타내는 제약조건으로, 하나 또는 그 이상의 개체가 참여한다.
- 가령, 직원은 여러 회사에서 무조건 일하지 않아도 괜찮으나, 회사는 직원이 무조건 있어야 한다 (전체 참여: *Total*)

The participation of Departments in Manages is said to be *total* (vs. *partial*)
- Every *did* value in Departments table must appear in a row of the Manages table (여기서 SSN은 null이 아니다).

For example, every department has a manager.

## Weak Entities(약한 개체)
![image](https://user-images.githubusercontent.com/39285147/190269229-1244c261-73b5-4c6f-9822-8b0a01c7f13a.png)

**Weak entity**: 자신의 key attribute가 없는 entity type (i.e., 어떤 강의에서 분반은 자신의 key attribute이 없고 강의 테이블에 의존한다); can be identified uniquely only by considering the primary key of another (owner) entity
- *one-to-many relationship* (one: owner)
- *total participation*

## ISA('is a') Hierarchies
![image](https://user-images.githubusercontent.com/39285147/190271387-65436bb6-6b10-4d37-bdc7-cb5b214230b0.png)

*A ISA B*: every A entity is also considered to be a B entity.

상위클래스(Superclass)-하위클래스(Subclass)의 관계이다.

**Overlap Constraints**: Can Joe be an Hourly_Emps as well as a Contrat_Emps entity? (Allowed/disallowed)

**Covering Constraints**: Does every Employees entity also have to be an Hourly_Emps or a Contract_Emps entity? (Y/N)

d