---
layout: single
title: "DBMS: Transaction Management"
categories: DB
tag: [Database, Transaction Management]
toc: true
toc_sticky: true
toc_label: "ì­ŒìŠ¤log"
#author_profile: false
header:
    teaser: /assets/images/posts/db.png
sidebar:
    nav: "docs"
---

# INTRO ğŸ™Œ
ì €ë²ˆ ì‹œê°„ì—ëŠ” Query Optimization ì— ëŒ€í•˜ì—¬ ì•Œì•„ë³´ì•˜ë‹¤.

ì´ë²ˆ ì‹œê°„ì—ëŠ” **Transaction Management**ì— ëŒ€í•´ ì•Œì•„ë³´ì.

# ACID ğŸ”
        Atomic, consistent, isolation, durable

- Execute each transaction **atomically**; execute as a single unit
    - Transaction ì¤‘ê°„ì— crash --> ì§„í–‰ ì‘ì—… ëª¨ë‘ ì´ˆê¸°í™”
- **Isolation**: if two users run transactions concurrently, they should not interfere with each other
    - e.g., moving $20 from checking to saving AND return the balance (the sum of checking + saving)
    - what do we want in this case? **sequential execution** of the two transactions
- **Durable**: if a transaction has been executed, its effect is persisted in the database

## 1) Atomicity
> Responsibility: Transaction Control Manager

![image](https://user-images.githubusercontent.com/39285147/206877971-ff8d4961-175e-4a2a-a396-cee12e98d99b.png)

        Accounts(id, checking, saving)

        // Q1: checking ê³„ì¢Œ ê¸ˆì•¡ ì‚­ê°
        UPDATE Accounts
        SET checking = checking â€“ 20
        WHERE id = 123

        // Q2: saving ê³„ì¢Œ ê¸ˆì•¡ ì¶”ê°€
        UPDATE Accounts
        SET saving = saving + 20
        Where id = 123

ìš°ë¦¬ëŠ” checking ê³„ì¢Œì—ì„œ saving ê³„ì¢Œë¡œ ëˆì„ ì´ì²´í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ê³ ì í•œë‹¤.

ë§Œì•½, Q1, Q2 ì¿¼ë¦¬ë“¤ì„ ë‹¨ë…ìœ¼ë¡œ ì‹¤í–‰í•˜ë‹¤ê°€, ì¤‘ê°„ì— crashê°€ ë‚˜ê±°ë‚˜ 0ì„ ë‚˜ëˆ ì„œ segmentation fault ë“± ì—ëŸ¬ê°€ ë°œìƒí•  ê²½ìš°, checking ê³„ì¢Œì—ì„œ ëˆë§Œ ìƒì–´ë²„ë¦¬ëŠ” í˜„ìƒì´ ë°œìƒí• ì§€ë„ ëª¨ë¥¸ë‹¤.

ì´ëŸ¬í•œ í˜„ìƒì„ ìš°ë¦¬ëŠ” **"Inconsistent" state**ë¼ê³  ì¼ì»«ëŠ”ë‹¤.
- "inconsistency" is subjective, depending on the business logic of the app

ì´ëŸ¬í•œ inconsistencyë¼ëŠ” í•œê³„ì ì„ íƒ€íŒŒí•˜ê³ ì ë“±ì¥í•œ ê²ƒì´ **Transaction**ì´ë‹¤.

## 2) Isolation
> Responsibility: concurrency control manager

ë‹¤ìˆ˜ Transactionì´ ë™ì‹œì ìœ¼ë¡œ ë™ì‘í•  ê²½ìš°, ì¶©ëŒì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

        SELECT (checking + saving)
        FROM Accounts
        WHERE id = 123

Q3ë¼ëŠ” í•œ idì˜ checkingê³¼ saving ê¸ˆì•¡ì˜ í•©ì„ ë°°ì¶œí•˜ëŠ” ì¿¼ë¦¬ê°€ Transaction 2 (T2)ë¼ê³  í•´ë³´ì.

T1 ì‹¤í–‰ ì¤‘, Q1 ì‹¤í–‰ìœ¼ë¡œ checking ê¸ˆì•¡ì´ 20 ê°ì†Œí•˜ìë§ˆì Q3ê°€ ì‹¤í–‰ëœë‹¤ë©´, ì´ ê¸ˆì•¡ì€ 20 ê°ì†Œëœ í•©ìœ¼ë¡œ ë°°ì¶œë  ê²ƒì´ë‹¤.

![image](https://user-images.githubusercontent.com/39285147/206878542-64974b56-40c7-4ffc-967b-31a7fb2ea144.png)

ìƒê¸° ì´ë¯¸ì§€ì²˜ëŸ¼, 105ê°€ ì´í•©ì´ì—¬ì•¼ í•˜ëŠ”ë°, Q3ëŠ” 85ë¥¼ ë°°ì¶œí•˜ëŠ” ëª¨ìŠµì´ë‹¤.

ê°€ë ¹, í•˜ë‚˜ì˜ ë¹„í–‰ê¸° í‹°ì¼“ì„ ì—¬ëŸ¬ ì‚¬ëŒì´ ë™ì‹œì— ì˜ˆì•½í•˜ê³ , ëª¨ë‘ê°€ ì˜ˆì•½ì´ ì„±ê³µë˜ë²„ë¦¬ëŠ” ë¬¸ì œì ì´ í•œ ì˜ˆì‹œì´ë‹¤.

![image](https://user-images.githubusercontent.com/39285147/206878725-6a040f21-a60f-4bf0-a55d-f871c3ad5963.png)

ë”°ë¼ì„œ, ìš°ë¦¬ëŠ” T1, T2ê°€ ìƒê¸° ìˆœì„œ ë‘˜ ì¤‘ ì•„ë¬´ í•˜ë‚˜ì˜ ìˆœì„œë¡œ ê°œë³„ì ìœ¼ë¡œ ë™ì‘í•˜ê¸¸ ë°”ë€ë‹¤.

## 3) Durable
> Responsibility: DBMS and application programmer

ë§Œì•½ logì—ì„œ end transaction í‘œì‹œê°€ ìˆë‹¤ë©´, DBì— ë¬´ì¡°ê±´ í•´ë‹¹ ì¿¼ë¦¬ ì‘ì—…ì´ ë°˜ì˜ë˜ìˆì–´ì•¼ í•œë‹¤.

## 4) Consistency
> Responsibility: recovery manager

- depends on who is writing the transaction, not Database System
    - consistencyëŠ” ì‹œìŠ¤í…œì´ ë³´ì¥í•  ìˆ˜ ì—†ê³ , í”„ë¡œê·¸ë˜ë¨¸ê°€ ì±…ì„ì ¸ì•¼ í•œë‹¤.

****
# ë°°ê²½ì§€ì‹ ğŸŸ
## System Failures
- Each transaction has internal state
- When system crashes, internal state is lost
    - Donâ€™t know which parts executed and which didnâ€™t
- Remedy: use a **log**
    - A file that records every single action of the transaction

## Transaction
**Transaction**: a sequence of SQL statements that you want to execute as a single *atomic* unit
    - transaction ì‹¤í–‰ (ë¬´ì¡°ê±´ ë‘˜ ì¤‘ í•˜ë‚˜):
        - ëª¨ë“  statements ë‹¤ ì‹¤í–‰
        - ì•„ì— ì•„ë¬´ê²ƒë„ ì‹¤í–‰ x
    - transaction ì¤‘ê°„ì— ì•ˆ ë©ˆì¶”ë©´ consistent ë³´ì¥
    - transaction ì¤‘ê°„ì— ë©ˆì¶”ê¸° ë¶ˆê°€ëŠ¥; inconsistent state
    - DB = elements ì§‘í•©ì²´
        - Usually 1 element = 1 block
        - Can be smaller (=1 record) or larger (=1 relation)
    - ê° transaction reads/writes some elements

Transactionì€ í•˜ë‚˜ì˜ ë‹¨ìœ„ë¡œ ì‹¤í–‰í•˜ê³ ì í•˜ëŠ” ì¿¼ë¦¬ë¬¸ë“¤ì„ start/end transaction ì‚¬ì´ì— ìœ„ì¹˜ì‹œí‚¨ë‹¤.

        Accounts(id, checking, saving)
        START TRANSACTION
        UPDATE Accounts
        SET checking = checking â€“ 20
        WHERE id = 123
        UPDATE Accounts
        SET saving = saving + 20
        Where id = 123
        END TRANSACTION

        SELECT (checking + saving)
        FROM Accounts
        WHERE id = 123

DBë¡œì˜ ìµœì¢… **commit**ì€ end transactionì—ì„œ ë°œìƒí•˜ë©°, ë§Œì•½ ì¿¼ë¦¬ë¬¸ ì‚¬ì´ ì¤‘ê°„ì— ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°, ì¬ë¶€íŒ…í•˜ìë§ˆì ì‹¤í–‰ëœ ì¿¼ë¦¬ë¬¸ë“¤ì— ëŒ€í•´ **roll back**ì„ ì§„í–‰í•œë‹¤.
- In ad-hoc SQL
    - each command = 1 transaction
- In embedded SQL (say inside a Python program)
    - Transaction starts = first SQL command issued
    - Transaction ends =
        - COMMIT
        - ROLLBACK (=abort)

ê°€ë ¹, checking ê³„ì¢Œì—ì„œ 20ì„ ì‚­ê°í•˜ê³  crash ë°œìƒí•œ ê²½ìš°, ì¬ë¶€íŒ…í•˜ìë§ˆì checking ê³„ì¢Œì— 20ì„ ë˜ëŒë ¤ ë†“ëŠ”ë‹¤.

> ì–´ë–»ê²Œ roll backì„ ì§„í–‰í•˜ë‚˜?
>
> ![image](https://user-images.githubusercontent.com/39285147/206878215-ec356bac-0a7a-4f96-bf3d-08bb92939f08.png)
>
> transaction start, Q1 ì‹¤í–‰ ë“± [**log**](#log)ë¡œì¨ ì €ì¥ë˜ëŠ” ëª¨ìŠµì´ë‹¤. ì´ ë•Œ, Q1 ì‹¤í–‰ ì •ë³´ë¡œ idì™€ ê°™ì€ ê°’ë“¤ì´ ê°™ì´ ì €ì¥ë˜ì„œ, ë§Œì•½ logì— end transactionì´ ì—†ë‹¤ë©´, DBì—ì„œ í•´ë‹¹ idì— ë“¤ì–´ê°€ roll backì„ ì§„í–‰í•œë‹¤.

### Primitive Operations of Transactions
- INPUT(X)
    - read element X(DISK) to memory buffer
- READ(X,t)
    - copy element X(MEMORY) to transaction local variable t
- WRITE(X,t)
    - copy transaction local variable t to element X(MEMORY)
- OUTPUT(X)
    - write element X(MEMORY) to disk

        READ(A,t); t := t*2;WRITE(A,t)
        READ(B,t); t := t*2;WRITE(B,t)

![image](https://user-images.githubusercontent.com/39285147/207052170-87690080-a71e-4d75-b2c5-e254f6893129.png)

- ***â€» WRITE(A, t)ì™€ READ(B, t) ì‚¬ì´ì— INPUT(B) ë¹ ì§***

## Log
- An *append-only* file containing log records
- Note: multiple transactions run concurrently, log records are interleaved
- After a system crash, use log to:
    - Redo some transaction that didnâ€™t commit
    - Undo other transactions that didnâ€™t commit

### Log records
`<START T>`
- transaction T has begun

`<COMMIT T>`
- T has committed

`<ABORT T>`
- T has aborted

`<T,X,v>`
- T has updated element X, and its old value was v

### Undo Logging
- U1: If T modifies X, then <T,X,v> must be written to disk before X is written to disk
- U2: If T commits, then <COMMIT T> must be written to disk only after all changes by T are written to disk

> OUTPUTs are done early

![image](https://user-images.githubusercontent.com/39285147/207053522-80cd7744-cb2c-4ae7-a6d4-14ad1bcaf94b.png)

****
# ACID: Lock and Crash Recovery ğŸ¥©
## 1) Lock
![image](https://user-images.githubusercontent.com/39285147/206879244-29ad0de9-ce31-4d0b-ba81-edf9af4b6390.png)

T1ì„ ì‹¤í–‰í•˜ìë§ˆì ìˆ˜ì •í•˜ëŠ” ë°ì´í„°ì— lockì„ ë¶€ì—¬í•œ í›„, ì¿¼ë¦¬ë¥¼ ì‹¤í–‰í•œë‹¤.

ì´ë•Œ, T1ì´ ì™„ë£Œ ë˜ê¸° ì „ì— T2ê°€ ë“¤ì–´ì˜¨ ê²½ìš°, T2ëŠ” awaiting ìƒíƒœë¡œ ëŒì…í•œë‹¤.

T1 ì™„ë£Œ ì§í›„, T2ëŠ” ì‡ë‹¬ì•„ ì‹¤í–‰ëœë‹¤.

Lockì€ Crashë¥¼ ì¡ì•„ë‚´ì§€ ëª»í•˜ê¸° ë•Œë¬¸ì—, T1 ì‹¤í–‰ ë„ì¤‘ crashê°€ ë°œìƒí•œ ê²½ìš°ì— ëŒ€í•œ ì²˜ë¦¬ëŠ” ë¶ˆê°€ëŠ¥í•˜ë‹¤.

ë”°ë¼ì„œ, logì— lockì— ëŒ€í•œ ì–¸ê¸‰ ì—­ì‹œ í•´ì¤˜ì•¼ í•œë‹¤.

ê·¸ëŸ¬ë©´, ì¬ë¶€íŒ… ì´í›„, lockì´ ê±¸ë¦° ë°ì´í„° ì—­ì‹œ ë‹¤ì‹œ lockì„ í•´ì œí•˜ì—¬, lockë¼ë¦¬ë„ ì¶©ëŒì´ ë‚˜ëŠ” ë¬¸ì œì ì„ í•´ê²° ê°€ëŠ¥í•˜ë‹¤.

> ì „ì²´ DB Table lock ê±¸ë©´ ì•ˆ ë˜ëŠ” ì´ìœ 
>> Lock ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ìƒˆë¡œìš´ Transactionì´ ë˜ ë‹¤ì‹œ Lock ê±¸ì–´ì„œ ë¬´í•œìœ¼ë¡œ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆìŒ.

### Read/Write Lock
> Throughput ìµœëŒ€í™”!

- Read Lock ê±¸ë¦¼
    - Readë§Œ ê°€ëŠ¥, Write ë¶ˆê°€ëŠ¥
- Write Lock ê±¸ë¦¼
    - R/W ëª¨ë‘ ë¶ˆê°€ëŠ¥

## 2) Crash Recovery
### Recovery manager
Read log from the end; cases:
- `<COMMIT T>`:  mark T as completed
- `<ABORT T>`: mark T as completed
- `<T,X,v>`:

        if T is not completed
            then write X=v to disk
        else ignore
    
- `<START T>`: ignore

### â‘  Recovery with Undo Log
![image](https://user-images.githubusercontent.com/39285147/207054441-38ac2b47-f36b-40f9-9687-c8bfa212b9bd.png)

- Whether T is completed or not; undo all modifications by incompleted transactions

            `<START T>`â€¦.`<COMMIT T>`â€¦.    = yes
            `<START T>`â€¦.`<ABORT T>`â€¦â€¦.   = yes
            `<START T>`â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦   = no

- All undo commands are **idempotent**
    - If we perform them a second time, no harm is done
    - E.g. if there is a system crash during recovery, simply restart recovery from scratch

- í•œê³„: Cannot stop until we reach the beginning of the log file (impractical)
    - Better idea: use **checkpointing**

### â‘¡ Checkpointing



****
# Reference 
[Database Management Systems by Raghu Ramakrishnan and Johannes Gehrke](https://pages.cs.wisc.edu/~dbbook/)