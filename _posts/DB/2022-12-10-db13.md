---
layout: single
title: "DBMS: Transaction Management"
categories: DB
tag: [Database, Transaction Management]
toc: true
toc_sticky: true
toc_label: "ì­ŒìŠ¤log"
#author_profile: false
header:
    teaser: /assets/images/posts/db.png
sidebar:
    nav: "docs"
---

****
# INTRO ğŸ™Œ
ì €ë²ˆ ì‹œê°„ì—ëŠ” Query Optimization ì— ëŒ€í•˜ì—¬ ì•Œì•„ë³´ì•˜ë‹¤.

ì´ë²ˆ ì‹œê°„ì—ëŠ” **Transaction Management**ì— ëŒ€í•´ ì•Œì•„ë³´ì.

****
# ACID ğŸ”
        Atomic, consistent, isolation, durable

- Execute each transaction **atomically**; execute as a single unit
    - Transaction ì¤‘ê°„ì— crash --> ì§„í–‰ ì‘ì—… ëª¨ë‘ ì´ˆê¸°í™”
- **Isolation**: if two users run transactions concurrently, they should not interfere with each other
    - e.g., moving $20 from checking to saving AND return the balance (the sum of checking + saving)
    - what do we want in this case? **sequential execution** of the two transactions
- **Durable**: if a transaction has been executed, its effect is persisted in the database

## 1) Atomicity
> Responsibility: Transaction Control Manager

![image](https://user-images.githubusercontent.com/39285147/206877971-ff8d4961-175e-4a2a-a396-cee12e98d99b.png)

        Accounts(id, checking, saving)

        // Q1: checking ê³„ì¢Œ ê¸ˆì•¡ ì‚­ê°
        UPDATE Accounts
        SET checking = checking â€“ 20
        WHERE id = 123

        // Q2: saving ê³„ì¢Œ ê¸ˆì•¡ ì¶”ê°€
        UPDATE Accounts
        SET saving = saving + 20
        Where id = 123

ìš°ë¦¬ëŠ” checking ê³„ì¢Œì—ì„œ saving ê³„ì¢Œë¡œ ëˆì„ ì´ì²´í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ê³ ì í•œë‹¤.

ë§Œì•½, Q1, Q2 ì¿¼ë¦¬ë“¤ì„ ë‹¨ë…ìœ¼ë¡œ ì‹¤í–‰í•˜ë‹¤ê°€, ì¤‘ê°„ì— crashê°€ ë‚˜ê±°ë‚˜ 0ì„ ë‚˜ëˆ ì„œ segmentation fault ë“± ì—ëŸ¬ê°€ ë°œìƒí•  ê²½ìš°, checking ê³„ì¢Œì—ì„œ ëˆë§Œ ìƒì–´ë²„ë¦¬ëŠ” í˜„ìƒì´ ë°œìƒí• ì§€ë„ ëª¨ë¥¸ë‹¤.

ì´ëŸ¬í•œ í˜„ìƒì„ ìš°ë¦¬ëŠ” **"Inconsistent" state**ë¼ê³  ì¼ì»«ëŠ”ë‹¤.
- "inconsistency" is subjective, depending on the business logic of the app

ì´ëŸ¬í•œ inconsistencyë¼ëŠ” í•œê³„ì ì„ íƒ€íŒŒí•˜ê³ ì ë“±ì¥í•œ ê²ƒì´ **Transaction**ì´ë‹¤.

## 2) Isolation
> Responsibility: concurrency control manager

ë‹¤ìˆ˜ Transactionì´ ë™ì‹œì ìœ¼ë¡œ ë™ì‘í•  ê²½ìš°, ì¶©ëŒì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

        SELECT (checking + saving)
        FROM Accounts
        WHERE id = 123

Q3ë¼ëŠ” í•œ idì˜ checkingê³¼ saving ê¸ˆì•¡ì˜ í•©ì„ ë°°ì¶œí•˜ëŠ” ì¿¼ë¦¬ê°€ Transaction 2 (T2)ë¼ê³  í•´ë³´ì.

T1 ì‹¤í–‰ ì¤‘, Q1 ì‹¤í–‰ìœ¼ë¡œ checking ê¸ˆì•¡ì´ 20 ê°ì†Œí•˜ìë§ˆì Q3ê°€ ì‹¤í–‰ëœë‹¤ë©´, ì´ ê¸ˆì•¡ì€ 20 ê°ì†Œëœ í•©ìœ¼ë¡œ ë°°ì¶œë  ê²ƒì´ë‹¤.

![image](https://user-images.githubusercontent.com/39285147/206878542-64974b56-40c7-4ffc-967b-31a7fb2ea144.png)

ìƒê¸° ì´ë¯¸ì§€ì²˜ëŸ¼, 105ê°€ ì´í•©ì´ì—¬ì•¼ í•˜ëŠ”ë°, Q3ëŠ” 85ë¥¼ ë°°ì¶œí•˜ëŠ” ëª¨ìŠµì´ë‹¤.

ê°€ë ¹, í•˜ë‚˜ì˜ ë¹„í–‰ê¸° í‹°ì¼“ì„ ì—¬ëŸ¬ ì‚¬ëŒì´ ë™ì‹œì— ì˜ˆì•½í•˜ê³ , ëª¨ë‘ê°€ ì˜ˆì•½ì´ ì„±ê³µë˜ë²„ë¦¬ëŠ” ë¬¸ì œì ì´ í•œ ì˜ˆì‹œì´ë‹¤.

![image](https://user-images.githubusercontent.com/39285147/206878725-6a040f21-a60f-4bf0-a55d-f871c3ad5963.png)

ë”°ë¼ì„œ, ìš°ë¦¬ëŠ” T1, T2ê°€ ìƒê¸° ìˆœì„œ ë‘˜ ì¤‘ ì•„ë¬´ í•˜ë‚˜ì˜ ìˆœì„œë¡œ ê°œë³„ì ìœ¼ë¡œ ë™ì‘í•˜ê¸¸ ë°”ë€ë‹¤.

## 3) Durable
> Responsibility: DBMS and application programmer

ë§Œì•½ logì—ì„œ end transaction í‘œì‹œê°€ ìˆë‹¤ë©´, DBì— ë¬´ì¡°ê±´ í•´ë‹¹ ì¿¼ë¦¬ ì‘ì—…ì´ ë°˜ì˜ë˜ìˆì–´ì•¼ í•œë‹¤.

## 4) Consistency
> Responsibility: recovery manager

- depends on who is writing the transaction, not Database System
    - consistencyëŠ” ì‹œìŠ¤í…œì´ ë³´ì¥í•  ìˆ˜ ì—†ê³ , í”„ë¡œê·¸ë˜ë¨¸ê°€ ì±…ì„ì ¸ì•¼ í•œë‹¤.

****
# ë°°ê²½ì§€ì‹ ğŸŸ
## System Failures
- Each transaction has internal state
- When system crashes, internal state is lost
    - Donâ€™t know which parts executed and which didnâ€™t
- Remedy: use a **log**
    - A file that records every single action of the transaction

## Transaction
**Transaction**: a sequence of SQL statements that you want to execute as a single *atomic* unit
- transaction ì‹¤í–‰ (ë¬´ì¡°ê±´ ë‘˜ ì¤‘ í•˜ë‚˜):
    - ëª¨ë“  statements ë‹¤ ì‹¤í–‰
    - ì•„ì— ì•„ë¬´ê²ƒë„ ì‹¤í–‰ x
- transaction ì¤‘ê°„ì— ì•ˆ ë©ˆì¶”ë©´ consistent ë³´ì¥
- transaction ì¤‘ê°„ì— ë©ˆì¶”ê¸° ë¶ˆê°€ëŠ¥; inconsistent state
- DB = elements ì§‘í•©ì²´
    - Usually 1 element = 1 block
    - Can be smaller (=1 record) or larger (=1 relation)
- ê° transaction reads/writes some elements

Transactionì€ í•˜ë‚˜ì˜ ë‹¨ìœ„ë¡œ ì‹¤í–‰í•˜ê³ ì í•˜ëŠ” ì¿¼ë¦¬ë¬¸ë“¤ì„ start/end transaction ì‚¬ì´ì— ìœ„ì¹˜ì‹œí‚¨ë‹¤.

        Accounts(id, checking, saving)
        START TRANSACTION
        UPDATE Accounts
        SET checking = checking â€“ 20
        WHERE id = 123
        UPDATE Accounts
        SET saving = saving + 20
        Where id = 123
        END TRANSACTION

        SELECT (checking + saving)
        FROM Accounts
        WHERE id = 123

DBë¡œì˜ ìµœì¢… **commit**ì€ end transactionì—ì„œ ë°œìƒí•˜ë©°, ë§Œì•½ ì¿¼ë¦¬ë¬¸ ì‚¬ì´ ì¤‘ê°„ì— ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°, ì¬ë¶€íŒ…í•˜ìë§ˆì ì‹¤í–‰ëœ ì¿¼ë¦¬ë¬¸ë“¤ì— ëŒ€í•´ **roll back**ì„ ì§„í–‰í•œë‹¤.
- In ad-hoc SQL
    - each command = 1 transaction
- In embedded SQL (say inside a Python program)
    - Transaction starts = first SQL command issued
    - Transaction ends =
        - COMMIT
        - ROLLBACK (=abort)

ê°€ë ¹, checking ê³„ì¢Œì—ì„œ 20ì„ ì‚­ê°í•˜ê³  crash ë°œìƒí•œ ê²½ìš°, ì¬ë¶€íŒ…í•˜ìë§ˆì checking ê³„ì¢Œì— 20ì„ ë˜ëŒë ¤ ë†“ëŠ”ë‹¤.

> ì–´ë–»ê²Œ roll backì„ ì§„í–‰í•˜ë‚˜?
>
> ![image](https://user-images.githubusercontent.com/39285147/206878215-ec356bac-0a7a-4f96-bf3d-08bb92939f08.png)
>
> transaction start, Q1 ì‹¤í–‰ ë“± [**log**](#log)ë¡œì¨ ì €ì¥ë˜ëŠ” ëª¨ìŠµì´ë‹¤. ì´ ë•Œ, Q1 ì‹¤í–‰ ì •ë³´ë¡œ idì™€ ê°™ì€ ê°’ë“¤ì´ ê°™ì´ ì €ì¥ë˜ì„œ, ë§Œì•½ logì— end transactionì´ ì—†ë‹¤ë©´, DBì—ì„œ í•´ë‹¹ idì— ë“¤ì–´ê°€ roll backì„ ì§„í–‰í•œë‹¤.

### Primitive Operations of Transactions
- INPUT(X)
    - read element X(DISK) to memory buffer
- READ(X,t)
    - copy element X(MEMORY) to transaction local variable t
- WRITE(X,t)
    - copy transaction local variable t to element X(MEMORY)
- OUTPUT(X)
    - write element X(MEMORY) to disk

            READ(A,t); t := t*2;WRITE(A,t)
            READ(B,t); t := t*2;WRITE(B,t)

![image](https://user-images.githubusercontent.com/39285147/207052170-87690080-a71e-4d75-b2c5-e254f6893129.png)

- ***â€» WRITE(A, t)ì™€ READ(B, t) ì‚¬ì´ì— INPUT(B) ë¹ ì§***

## Log
- An *append-only* file containing log records
- Note: multiple transactions run concurrently, log records are interleaved
- After a system crash, use log to:
    - Redo some transaction that didnâ€™t commit
    - Undo other transactions that didnâ€™t commit

****
# ACID: Lock and Crash Recovery ğŸ¥©
## 1) Lock
![image](https://user-images.githubusercontent.com/39285147/206879244-29ad0de9-ce31-4d0b-ba81-edf9af4b6390.png)

T1ì„ ì‹¤í–‰í•˜ìë§ˆì ìˆ˜ì •í•˜ëŠ” ë°ì´í„°ì— lockì„ ë¶€ì—¬í•œ í›„, ì¿¼ë¦¬ë¥¼ ì‹¤í–‰í•œë‹¤.

ì´ë•Œ, T1ì´ ì™„ë£Œ ë˜ê¸° ì „ì— T2ê°€ ë“¤ì–´ì˜¨ ê²½ìš°, T2ëŠ” awaiting ìƒíƒœë¡œ ëŒì…í•œë‹¤.

T1 ì™„ë£Œ ì§í›„, T2ëŠ” ì‡ë‹¬ì•„ ì‹¤í–‰ëœë‹¤.

Lockì€ Crashë¥¼ ì¡ì•„ë‚´ì§€ ëª»í•˜ê¸° ë•Œë¬¸ì—, T1 ì‹¤í–‰ ë„ì¤‘ crashê°€ ë°œìƒí•œ ê²½ìš°ì— ëŒ€í•œ ì²˜ë¦¬ëŠ” ë¶ˆê°€ëŠ¥í•˜ë‹¤.

ë”°ë¼ì„œ, logì— lockì— ëŒ€í•œ ì–¸ê¸‰ ì—­ì‹œ í•´ì¤˜ì•¼ í•œë‹¤.

ê·¸ëŸ¬ë©´, ì¬ë¶€íŒ… ì´í›„, lockì´ ê±¸ë¦° ë°ì´í„° ì—­ì‹œ ë‹¤ì‹œ lockì„ í•´ì œí•˜ì—¬, lockë¼ë¦¬ë„ ì¶©ëŒì´ ë‚˜ëŠ” ë¬¸ì œì ì„ í•´ê²° ê°€ëŠ¥í•˜ë‹¤.

> ì „ì²´ DB Table lock ê±¸ë©´ ì•ˆ ë˜ëŠ” ì´ìœ 
>> Lock ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ìƒˆë¡œìš´ Transactionì´ ë˜ ë‹¤ì‹œ Lock ê±¸ì–´ì„œ ë¬´í•œìœ¼ë¡œ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆìŒ.

### Read/Write Lock
> Throughput ìµœëŒ€í™”!

- Read Lock ê±¸ë¦¼
    - Readë§Œ ê°€ëŠ¥, Write ë¶ˆê°€ëŠ¥
- Write Lock ê±¸ë¦¼
    - R/W ëª¨ë‘ ë¶ˆê°€ëŠ¥

## 2) Crash Recovery
![image](https://user-images.githubusercontent.com/39285147/207089842-bad64fe2-e8a9-4620-b301-e855028ecaaf.png)

- 1) **Undo Logging** (force, steal)
    - OUTPUT must be done early
    - If `<COMMIT T>` is seen, T definitely has written all its data to disk (hence, donâ€™t need to undo)
    - ì¥ì 
        - Less memory intensive; flush updated data pages as soon as log records are flushed; only then COMMIT
    - ë‹¨ì 
        - higher latency (long time); forcing all dirty buffer pages to be flushed prior to COMMIT
- 2) **Redo Logging** (No force, no steal)
    - OUTPUT must be done late
    - If `<COMMIT T>` is not seen, T definitely has not written any of its data to disk (hence there is not dirty data on disk)
    - Would like more flexibility on when to OUTPUT: undo/redo logging (next)
    - ì¥ì 
        - Lower latency; do not need to wait until data pages are flushed to COMMIT
    - ë‹¨ì 
        - More memory intensive; cannot flush data pages unless COMMIT log has been flushed

- ~~3) **Undo/Redo Logging í˜¼í•©**~~ ì•ˆì¤‘ìš”

### Recovery manager
Read log from the end; cases:
- `<COMMIT T>`:  mark T as completed
- `<ABORT T>`: mark T as completed
- `<START T>`: ignore

### â‘  Recovery with Undo Log
`<T,X,v>`: T has updated element X, and its old value was v

- Whether T is completed or not; undo all modifications by incompleted transactions

            `<START T>`â€¦.`<COMMIT T>`â€¦.    = yes
            `<START T>`â€¦.`<ABORT T>`â€¦â€¦.   = yes
            `<START T>`â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦   = no

- All undo commands are **idempotent**
    - If we perform them a second time, no harm is done
    - E.g. if there is a system crash during recovery, simply restart recovery from scratch

- í•œê³„: Cannot stop until we reach the beginning of the log file (impractical)
    - Better idea: use **checkpointing**

#### Undo Logging ê·œì¹™
![image](https://user-images.githubusercontent.com/39285147/207053522-80cd7744-cb2c-4ae7-a6d4-14ad1bcaf94b.png)

- U1: If T modifies X, then <T,X,v> must be written to disk before X is written to disk
- U2: If T commits, then <COMMIT T> must be written to disk only after all changes by T are written to disk

> OUTPUTs are done early

ê¸°ë§ì¶œì œâ˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… (Log ë³´ê³  X ê°’ ìœ ì¶”í•˜ê¸°)

![image](https://user-images.githubusercontent.com/39285147/207054441-38ac2b47-f36b-40f9-9687-c8bfa212b9bd.png)

- `<T2,X2,v2>` --> X2=v2
- `<T3,X3,v3>` --> X3=v3
- `<COMMITT T5` --> ignore
- `<T4,X4,v4>` --> X4=v4
- `<T5,X5,v5>` --> ignore
- `<T1,X1,v1>` --> X1=v1
- `<START T4>` --> ignore
- `<START T5>` --> ignore

#### Checkpointing
![image](https://user-images.githubusercontent.com/39285147/207064083-833826f0-eced-4954-b43e-3c4f65086ea7.png)

- Checkpoint the database periodically
    - Stop accepting new transactions
    - Wait until all curent transactions complete
    - Flush log to disk
    - Write a <CKPT> log record, flush
    - Resume transactions
- í•œê³„: DB freezes during checkpoint

##### Nonquiescent Checkpointing
- Write a `<START CKPT(T1,â€¦,Tk)>` where T1,â€¦,Tk are all active transactions
- Continue normal operation
- When all of T1,â€¦,Tk have completed, write `<END CKPT>`

![image](https://user-images.githubusercontent.com/39285147/207065209-70421644-352f-4cf5-ba21-0bf56bf98c50.png)

            `<END CKPT>` --> ignore
            ...
            `<START CKPT T4, T5, T6>` --> ì¢…ë£Œ

- *T4,T5,T6*: active transactions
- `<START CKPT T4, T5, T6>`ì—ì„œ Log íƒìƒ‰ ì¢…ë£Œ
    - CKPT ë„ì¤‘ì— crash ë°œìƒ --> CKPT ê³¼ì • ë˜í•œ ì´ˆê¸°í™”
            
### â‘¡ Recovery with Redo Log
`<T,X,v>`= T has updated element X, and its new value is v
- Whether T is completed or not

        `<START T>`â€¦.`<COMMIT T>`â€¦.    = yes
        `<START T>`â€¦.`<ABORT T>`â€¦â€¦.    = yes
        `<START T>`â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦   = no

- Redo all updates of **committed transactions**

![image](https://user-images.githubusercontent.com/39285147/207071963-46b048c1-613a-48ac-97e3-56fdd2cedba5.png)

> redo logging ì‹œì‘ ì „ì— entire log í•œ ë²ˆ ì«™ í›‘ìœ¼ë©´ì„œ commit ì¡´ì¬í•˜ëŠ” transaction ë¯¸ë¦¬ ì•Œì•„ë†“ìŒ

- `<START T1>` --> ignore
- `<T1,X1,v1>` --> ignore (`<COMMIT T1>` ì—†ìŒ)
- `<START T2>` --> ignore
- `<T2,X2,v2>` --> write v2 to X2 on disk
- `<START T3>` --> ignore
- `<T1,X3,v3>` --> ignore (`<COMMIT T1>` ì—†ìŒ)
- `<COMMIT T2>` --> ignore
- `<T3,X4,v4>` --> ignore (`<COMMIT T3>` ì—†ìŒ)
- `<T1,X5,v5>` --> ignore (`<COMMIT T1>` ì—†ìŒ)

#### Redo Logging ê·œì¹™
![image](https://user-images.githubusercontent.com/39285147/207070718-dc819954-f249-402e-b566-3c9c0a799f95.png)

- R1: If T modifies X, then both `<T,X,v>` and `<COMMIT T>` must be written to disk before X is written to disk

> OUTPUTs are done late

#### Nonquiescent Checkpointing
- `<START CKPT(T1,â€¦,Tk)>` where T1,â€¦,Tk are all active transactions
- Flush to disk all blocks of committed transactions (*dirty blocks*), while continuing normal operation
- When all blocks have been written, write `<END CKPT>`

![image](https://user-images.githubusercontent.com/39285147/207091470-ceb862e4-b23a-42c3-87c7-17380cd52a12.png)

- `<START CKPT T4, T5, T6>` ì´ì „ ì‹œì  T4, T5, T6 ì œì™¸ ëª¨ë“  transactions redo ì§„í–‰
    - *T4,T5,T6*: `<START CKPT T4, T5, T6>` ì´ì „ ì‹œì  active uncommitted transactions
- `<START CKPT T4, T5, T6>` ì¼ë°˜ redo (committed transactionsë§Œ redo)
- `<END CKPT>`
    - `<START CKPT T4, T5, T6>` ì´ì „ commited transactions(*T1*) í™•ì‹¤íˆ disk ì¡´ì¬ ë³´ì¥ (dirty bit = 0)

![image](https://user-images.githubusercontent.com/39285147/207093121-cee7ce9b-7674-4bef-a466-4cf0099264fd.png)

### â‘¢ Undo/Redo Logging
`<T,X,u,v>`= T has updated element X, its old value was u, and its new value is v

$$Log\ records,\ only\ one\ change$$

![image](https://user-images.githubusercontent.com/39285147/207075278-4cfa0682-9f80-4d2a-9396-042c901877dd.png)

- Redo all committed transaction, top-down
- Undo all uncommitted transactions, bottom-up

#### Undo/Redo Logging ê·œì¹™
![image](https://user-images.githubusercontent.com/39285147/207074864-712bbc0f-2380-4ee0-b3a4-1cb50f5621b9.png)

UR1: If T modifies X, then <T,X,u,v> must be written to disk before X is written to disk

> OUTPUT early or late (I.e. before or after `<COMMIT T>`)

****
# Reference 
[Database Management Systems by Raghu Ramakrishnan and Johannes Gehrke](https://pages.cs.wisc.edu/~dbbook/)