---
layout: single
title: "DBMS: Transaction Management"
categories: DB
tag: [Database, Transaction Management]
toc: true
toc_sticky: true
toc_label: "쭌스log"
#author_profile: false
header:
    teaser: /assets/images/posts/db.png
sidebar:
    nav: "docs"
---

# INTRO 🙌
저번 시간에는 Query Optimization 에 대하여 알아보았다.

이번 시간에는 **Transaction Management**에 대해 알아보자.

# ACID 🍔
        Atomic, consistent, isolation, durable

- Execute each transaction **atomically**; execute as a single unit
    - Transaction 중간에 crash --> 진행 작업 모두 초기화
- **Isolation**: if two users run transactions concurrently, they should not interfere with each other
    - e.g., moving $20 from checking to saving AND return the balance (the sum of checking + saving)
    - what do we want in this case? **sequential execution** of the two transactions
- **Durable**: if a transaction has been executed, its effect is persisted in the database

## 1) Atomicity
![image](https://user-images.githubusercontent.com/39285147/206877971-ff8d4961-175e-4a2a-a396-cee12e98d99b.png)

        Accounts(id, checking, saving)

        // Q1: checking 계좌 금액 삭감
        UPDATE Accounts
        SET checking = checking – 20
        WHERE id = 123

        // Q2: saving 계좌 금액 추가
        UPDATE Accounts
        SET saving = saving + 20
        Where id = 123

우리는 checking 계좌에서 saving 계좌로 돈을 이체하는 시스템을 구현하고자 한다.

만약, Q1, Q2 쿼리들을 단독으로 실행하다가, 중간에 crash가 나거나 0을 나눠서 segmentation fault 등 에러가 발생할 경우, checking 계좌에서 돈만 잃어버리는 현상이 발생할지도 모른다.

이러한 현상을 우리는 **"Inconsistent" state**라고 일컫는다.
- "inconsistency" is subjective, depending on the business logic of the app

이러한 inconsistency라는 한계점을 타파하고자 등장한 것이 **Transaction**이다.

**Transaction**: a sequence of SQL statements that you want to execute as a single *atomic* unit
    - either all statements in the transaction would be executed, or none would be executed
    - if the app is consistent before a transaction, we assume that it will also be consistent after the transaction
    - you don’t want to execute a transaction half way; that can leave app in an inconsistent state

Transaction은 하나의 단위로 실행하고자 하는 쿼리문들을 start/end transaction 사이에 위치시킨다.

DB로의 최종 **commit**은 end transaction에서 발생하며, 만약 쿼리문 사이 중간에 에러가 발생하는 경우, 재부팅하자마자 실행된 쿼리문들에 대해 **roll back**을 진행한다.

가령, checking 계좌에서 20을 삭감하고 crash 발생한 경우, 재부팅하자마자 checking 계좌에 20을 되돌려 놓는다.

> 어떻게 roll back을 진행하나?
> ![image](https://user-images.githubusercontent.com/39285147/206878215-ec356bac-0a7a-4f96-bf3d-08bb92939f08.png)
> transaction start, Q1 실행 등 **log**로써 저장되는 모습이다. 이 때, Q1 실행 정보로 id와 같은 값들이 같이 저장되서, 만약 log에 end transaction이 없다면, DB에서 해당 id에 들어가 roll back을 진행한다.

## 2) Isolation
다수 Transaction이 동시적으로 동작할 경우, 충돌이 발생할 수 있다.

        SELECT (checking + saving)
        FROM Accounts
        WHERE id = 123

Q3라는 한 id의 checking과 saving 금액의 합을 배출하는 쿼리가 Transaction 2 (T2)라고 해보자.

T1 실행 중, Q1 실행으로 checking 금액이 20 감소하자마자 Q3가 실행된다면, 총 금액은 20 감소된 합으로 배출될 것이다.

![image](https://user-images.githubusercontent.com/39285147/206878542-64974b56-40c7-4ffc-967b-31a7fb2ea144.png)

상기 이미지처럼, 105가 총합이여야 하는데, Q3는 85를 배출하는 모습이다.

가령, 하나의 비행기 티켓을 여러 사람이 동시에 예약하고, 모두가 예약이 성공되버리는 문제점이 한 예시이다.

![image](https://user-images.githubusercontent.com/39285147/206878725-6a040f21-a60f-4bf0-a55d-f871c3ad5963.png)

따라서, 우리는 T1, T2가 상기 순서 둘 중 아무 하나의 순서로 개별적으로 동작하길 바란다.

## 3) Durable
만약 log에서 end transaction 표시가 있다면, DB에 무조건 해당 쿼리 작업이 반영되있어야 한다.

## 4) Consistency
- depends on who is writing the transaction, not Database System
    - consistency는 시스템이 보장할 수 없고, 프로그래머가 책임져야 한다.

****
# ACID: Lock and Crash Recovery 🥩
## 1) Lock
![image](https://user-images.githubusercontent.com/39285147/206879244-29ad0de9-ce31-4d0b-ba81-edf9af4b6390.png)

T1을 실행하자마자 수정하는 데이터에 lock을 부여한 후, 쿼리를 실행한다.

이때, T1이 완료 되기 전에 T2가 들어온 경우, T2는 awaiting 상태로 돌입한다.

T1 완료 직후, T2는 잇달아 실행된다.

Lock은 Crash를 잡아내지 못하기 때문에, T1 실행 도중 crash가 발생한 경우에 대한 처리는 불가능하다.

따라서, log에 lock에 대한 언급 역시 해줘야 한다.

그러면, 재부팅 이후, lock이 걸린 데이터 역시 다시 lock을 해제하여, lock끼리도 충돌이 나는 문제점을 해결 가능하다.

## 2) Crash Recovery

****
# Reference 
[Database Management Systems by Raghu Ramakrishnan and Johannes Gehrke](https://pages.cs.wisc.edu/~dbbook/)