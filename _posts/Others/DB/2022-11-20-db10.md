---
layout: single
title: "DBMS: External Sorting & Relational Operations"
categories: DB
tag: [Database, External Sorting, Relational Operations]
toc: true
toc_sticky: true
toc_label: "ì­ŒìŠ¤log"
#author_profile: false
header:
    teaser: /assets/images/posts/db.png
sidebar:
    nav: "docs"
---

# INTRO ğŸ™Œ
ì €ë²ˆ ì‹œê°„ì—ëŠ” Relational Algebra ì— ëŒ€í•˜ì—¬ ì•Œì•„ë³´ì•˜ë‹¤.

ì´ë²ˆ ì‹œê°„ì—ëŠ” **Sorting & Relational Operations**ì— ëŒ€í•´ ì•Œì•„ë³´ì.

****
# ì •ë ¬ì´ë€? ğŸ“‚
- CS ê³ ì „ì ì¸ ë¬¸ì œ
- ì •ë ¬ ë°ì´í„° í•„ìš” å¤š
- *bulk loading* B+ tree indexì—ì„œ ì •ë ¬ì€ ê°€ì¥ ì²« ê³¼ì œ!
- ì •ë ¬ì€ recordì— ì¡´ì¬í•˜ëŠ” duplicate copies ì œê±°ì— íš¨ê³¼ì ì´ë‹¤
- *Sort-merge* join ì•Œê³ ë¦¬ì¦˜ì€ ì •ë ¬ì„ ìˆ˜ë°˜í•œë‹¤

í•˜ì§€ë§Œ, ë§Œì•½ 1Gb í¬ê¸°ì˜ ë°ì´í„°ë¥¼ 1Mb ì‚¬ì–‘ì˜ RAMìœ¼ë¡œ ì •ë ¬ì„ ìˆ˜í–‰í•  ìˆ˜ ì—†ë‹¤.

> ì ì •ì  í•´ê²°ì±… = ê°€ìƒ ë©”ëª¨ë¦¬(virtual memory)

## 2-Way Sort: Requires 3 Buffers
![image](https://user-images.githubusercontent.com/39285147/202911804-876545b8-f79d-4cc0-9b2a-441e717ba6d5.png)

ì²« ë²ˆì§¸ ë‹¨ê³„:
- Read a page, sort it, write it.
- buffer page 1ê°œ; ê·¸ë¦¼ì—ì„œ ê°ê° *INPUT 1 and 2*

ë‘ ë²ˆì§¸ ë‹¨ê³„:
- Pass 2, 3, â€¦, etc.:
- buffer page 3ê°œ; ê·¸ë¦¼ì—ì„œ *INPUT 1, 2, and OUPUT*

### Two-Way External Merge Sort
![image](https://user-images.githubusercontent.com/39285147/202912630-de53230b-1afe-40e4-a6b8-eb70edb38e39.png)

- ê° passë§ˆë‹¤, ê° í˜ì´ì§€ r/w ìˆ˜í–‰
- ì—¬ì „íˆ buffer page 3ê°œ
- íŒŒì¼ í˜ì´ì§€ ê°œìˆ˜(N)ë¼ë©´,
    - $$the\ number\ of\ passes = \lceil log_{2}N\rceil+1$$.
    - $$total\ cost = 2N(\lceil log_{2}N\rceil+1)$$.
 - Idea: **Divide and conquer**: sort subfiles and merge

ìƒê¸° ì˜ˆë¬¸ì€ 8ê°œì˜ pagesê°€ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì—, total costëŠ” 8, pass ê°œìˆ˜ëŠ” 4ê°œì¸ ëª¨ìŠµì´ë‹¤.

## General External Merge Sort
![image](https://user-images.githubusercontent.com/39285147/202913412-09ed594b-5ad7-49b8-adbe-b25282dbb8bb.png)

Buffer page ê°œìˆ˜ê°€ 3ê°œ ë³´ë‹¤ ë§ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ë‹¤.

Nê°œì˜ í˜ì´ì§€ë¥¼ ê°€ì§„ íŒŒì¼ì„ Bê°œì˜ buffer pages ë‹¨ìœ„ë¡œ ì˜ë¼ì„œ ì •ë ¬:
- Pass 0: B buffer pages: ì •ë ¬ì¡°ê°ê°œìˆ˜=$$\lceil N/B\rceil$$ .
- Pass 2, â€¦,  etc.: merge $$(B-1)$$ runs. 

ì²« ë²ˆì§¸ ë‹¨ê³„ì—ì„œëŠ” Ní¬ê¸°ì˜ í•œ íŒŒì¼ì„ B ë‹¨ìœ„ë¡œ ì˜ë¼ì„œ ì •ë ¬ ì¡°ê°ì„ í˜•ì„±í•œë‹¤.

ì´í›„, ì´ˆê¸° $$(B-1)$$ê°œ ì •ë ¬ ì¡°ê°ì„ buffer pagesì— í• ë‹¹í•˜ê³ , ê²°ê³¼ë¥¼ ë‚˜ë¨¸ì§€ 1ê°œì˜ í˜ì´ì§€ì— ë‹´ëŠ”ë‹¤.

ì´ëŸ° ë°©ì‹ìœ¼ë¡œ, $$(B-1)$$ê°œì˜ buffer pages ë‹¨ìœ„ë¡œ ì •ë ¬ì„ ë°˜ë³µí•˜ë©° Nê³¼ ë™ì¼í•œ í¬ê¸°ì˜ í•˜ë‚˜ì˜ ì •ë ¬ ì¡°ê°ì„ í˜•ì„±í•œë‹¤.

### Cost of External Merge Sort
![image](https://user-images.githubusercontent.com/39285147/202914513-6bce1f59-f9a7-4151-83bb-620e991ef23c.png)

- pass ê°œìˆ˜: $$1+\lceil log_{B-1}(N/B)\rceil$$.
- ì´ cost: $$2N*(\#\ of\ passes)$$.
    - ê³±í•˜ê¸° 2í•˜ëŠ” ì´ìœ : ê° passë§ˆë‹¤ r/w ì ìš©
    - ê³±í•˜ê¸° Ní•˜ëŠ” ì´ìœ : ê° passë§ˆë‹¤ ëª¨ë“  í˜ì´ì§€ íƒìƒ‰
- $$B(B-1)^k=N$$.

### ì˜ˆì œ
5 buffer pagesë¥¼ ê°€ì§€ê³  108ê°œì˜ í˜ì´ì§€ íŒŒì¼ì„ ì •ë ¬í•´ë³´ì.
- Pass 0: ê°ê° 5í˜ì´ì§€ í¬ê¸°ì˜ 22ê°œì˜ ì •ë ¬ì¡°ê° í˜•ì„±; $$\lceil 108/ 5 \rceil = 22$$ *(ë§ˆì§€ë§‰ 3í˜ì´ì§€ í¬ê¸°)*
- Pass 1: ê°ê° 20í˜ì´ì§€ í¬ê¸°ì˜ 6ê°œì˜ ì •ë ¬ì¡°ê° í˜•ì„±; $$\lceil 22 / 4 \rceil = 6$$ *(ë§ˆì§€ë§‰ 8í˜ì´ì§€ í¬ê¸°)*
- Pass 2: 80í˜ì´ì§€ í¬ê¸° 1ê°œì™€ ë‚˜ë¨¸ì§€ 28í˜ì´ì§€ 1ê°œ, ì´ 2ê°œ ì •ë ¬ ì¡°ê°; $$\lceil 6 / 4 \rceil = 2$$.
- Pass 3: ìµœì¢… 108 í˜ì´ì§€ í¬ê¸° ì •ë ¬ ì¡°ê°

ê³µì‹ì„ ì ìš©í•´ë³´ì•„ë„ ë™ì¼í•˜ê²Œ, Pass ê°œìˆ˜ëŠ” 4, ì´ ë¹„ìš©ì€ 2x108x4ì´ë‹¤.

### ì¼ë°˜í™”
ë§Œì•½ íŒŒì¼ í˜ì´ì§€ ê°œìˆ˜ê°€ $$M$$ì´ê³ , $$M <= B^2$$ ë¼ë©´, ì´ ì •ë ¬ ë¹„ìš©ì€ $$4M$$ ì´ë‹¤.
- Pass 0: B í˜ì´ì§€ í¬ê¸° ì •ë ¬ ì¡°ê° í˜•ì„± (Cost of Pass 0: 2M)
- Pass 1: B(B-1) í˜ì´ì§€ í¬ê¸° ì •ë ¬ ì¡°ê° í˜•ì„± (Cost of Pass 1: 2M)
    - ë§Œì•½ $$M <= B^2$$ ë¼ë©´, ì´ ë‹¨ê³„ì—ì„œ ì¢…ë£Œ; $$M = B(B-1) <= B^2$$.

ë”°ë¼ì„œ, í•´ë‹¹ ê²½ìš° ì´ ë¹„ìš©ì´ **4M**ì´ ëœë‹¤.

### Double Buffering
- Reduce the response time for a given **sorting** query
- No significant impact on throughput
    - CPU can be kept busy by working on other queries while waiting for one query's I/O operation to complete.

External Sorting ë¬¸ì œì :
- ì…ë ¥ ë¸”ë¡ì˜ ëª¨ë“  íŠœí”Œ ì†Œë¹„ $$\rightarrow$$ íŠœí”Œì˜ ë‹¤ìŒ ë¸”ë¡ I/O ìš”ì²­ $$\rightarrow$$ I/Oê°€ ì‹¤í–‰ë  ë•Œê¹Œì§€ ì‹¤í–‰ ì¼ì‹œ ì¤‘ë‹¨ (CPU = idle)

**Double Buffering**
- I/O ìš”ì²­ì´ ìˆ˜í–‰ë˜ëŠ” ë™ì•ˆ CPUë¥¼ ì‚¬ìš© ì¤‘ì¸ ìƒíƒœë¡œ ìœ ì§€
    - CPU & I/O ì²˜ë¦¬ ì¤‘ì²©
        - ê° ì…ë ¥ ë²„í¼ì— ì¶”ê°€ í˜ì´ì§€ í• ë‹¹

ê°€ë ¹, ë¸”ë¡ í¬ê¸° b = 32ì— ëŒ€í•´, ëª¨ë“  ì…ë ¥(ë° ì¶œë ¥) ë²„í¼ì— ì¶”ê°€ 32í˜ì´ì§€ ë¸”ë¡ì„ í• ë‹¹í•œë‹¤. 32í˜ì´ì§€ ë¸”ë¡ì˜ ëª¨ë“  íŠœí”Œì´ ì†Œë¹„ë˜ë©´, CPUëŠ” ì´ ì‹¤í–‰ì— ëŒ€í•´ ë‘ ë²ˆì§¸ 'double' ë¸”ë¡ìœ¼ë¡œ ì „í™˜í•˜ì—¬ ì‹¤í–‰ì˜ ë‹¤ìŒ 32í˜ì´ì§€ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤. ë™ì‹œì—, ë¹ˆ ë¸”ë¡ì„ ì±„ìš°ê¸° ìœ„í•´ I/O ìš”ì²­ì´ ë°œí–‰ëœë‹¤. ë”°ë¼ì„œ, ë¸”ë¡ì„ ì†Œë¹„í•˜ëŠ” ì‹œê°„(ê¸°ì¡´ ë¸”ë¡ íŠœí”Œ ì†Œë¹„)ì´ ë¸”ë¡ì„ ì½ëŠ” ì‹œê°„(ë¹ˆ ë¸”ë¡ ì±„ìš°ê¸°)ë³´ë‹¤ í¬ë‹¤ê³  ê°€ì •í•˜ë©´ CPUëŠ” ì ˆëŒ€ ìœ íœ´ ìƒíƒœê°€ ì•„ë‹ˆê²Œ ëœë‹¤.

### ì‹¤ìŠµ
![image](https://user-images.githubusercontent.com/39285147/202915583-5174c857-aa94-4961-b17d-f5b30b9e9f22.png)

****
# Relational Operations ğŸ’—
- **Selection**  (  $$\sigma$$   )    Selects a subset of rows from relation.
- **Projection**  (  $$\pi$$   )      Deletes unwanted columns from relation.
- **Join**  (    $$\infty$$    )      Allows us to combine two relations.
- **Set-difference**  (   $$-$$  )    Tuples in reln. 1, but not in reln. 2.
- **Union**  (  $$\cup$$   )          Tuples in reln. 1 and in reln. 2.
- **Aggregation**  (SUM, MIN, etc.) and GROUP BY

## Schema for Examples
        Sailors (sid: integer, sname: string, rating: integer, age: real)
        Reserves (sid: integer, bid: integer, day: dates, rname: string)

- *Reserves*: Each tuple is 40 bytes long,  100 tuples per page, 1000 pages.
- *Sailors*: Each tuple is 50 bytes long,  80 tuples per page, 500 pages. 

## Equality Joins With One Join Column
        SELECT  *
        FROM     Reserves R1, Sailors S1
        WHERE  R1.sid=S1.sid

$$R\infty S$$: ëŒ€ìˆ˜í•™ì—ì„œ ì¢…ì¢… ì‚¬ìš©ë˜ì§€ë§Œ, ìµœì í™”ì— ì£¼ì˜í•´ì•¼ í•œë‹¤.
- $$R X S$$ì€ í¬ê¸°ê°€ ë§¤ìš° í¬ê¸° ë•Œë¬¸ì—, ì´í›„ì— *Selection* ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì§€ì–‘í•´ì•¼ í•œë‹¤.

ì´ì œë¶€í„° ì‚´í´ë³¼ ì˜ˆë¬¸ë“¤ì—ì„œ ë‹¤ìŒ ì¡°ê±´ë“¤ì„ ì¶©ì¡±í•œë‹¤ê³  ê°€ì •í•´ë³´ì.

- M pages for R, $$p_{R}$$ tuples per page
- N pages for S, $$p_{S}$$ tuples per page
- R = Reserves | S = Sailors.
- **Cost metric**: $$\#\ of\ I/Os$$  .
    - output costsëŠ” ë¬´ì‹œí•œë‹¤

## Join Algorithms to Consider
- Nested loop join
- Sort-merge join
- Hash join
- Index nested loop join

> ìƒê¸° JOIN ê°ê° ëª¨ë‘ ì´í•´ â˜…â˜…â˜…â˜…â˜…â˜…
>> cost êµ¬í•˜ëŠ” ë¬¸ì œ ì¶œì œ â˜…â˜…â˜…â˜…â˜…â˜…

### ë¹„êµ
![image](https://user-images.githubusercontent.com/39285147/202923544-81dfdb95-d485-4412-8c17-92c79589787d.png)

![image](https://user-images.githubusercontent.com/39285147/202923617-96acaa59-22f1-4e2a-a136-ee702f81af81.png)

### 1) Nested loop join
#### Simple Nested Loops Join
        foreach tuple r in R do
            foreach tuple s in S do
                if ri == sj  then add <r, s> to result

![image](https://user-images.githubusercontent.com/39285147/202919261-daf0d6d6-bfdd-452f-97cb-ae95ac82045b.png)

Tuple-oriented NLJ
- *outer* relation Rì— ì¡´ì¬í•˜ëŠ” ê° tupleì— ëŒ€í•˜ì—¬, *inner* relation Së¥¼ ìŠ¤ìº”í•œë‹¤.
- $$Cost\ =\ M+p_{R}*M*N = 1000 + 100*1000*500$$ I/Os

Page-oriented NLJ
- Rì˜ ê° í˜ì´ì§€ì— ëŒ€í•˜ì—¬, Sì˜ ê° í˜ì´ì§€ë¥¼ ê°€ì ¸ì™€ $$<r,s>$$ ì‘ì„±.
- $$Cost\ =\ M + M*N = 1000 + 1000*500$$.

> *# output pages to disk*ë¥¼ Cost ê³„ì‚°ì—ì„œ ì œì™¸í•˜ëŠ” ì´ìœ ?
>> ì›ë˜ $$Cost\ =\ M + M*N + (output\ pages)$$. ì—¬ê¸°ì„œ, CostëŠ” ì„œë¡œ ë‹¤ë¥¸ implementationsì— ëŒ€í•œ JOIN ì„±ëŠ¥ ë¹„êµë¥¼ ìœ„í•´ ê³„ì‚°í•˜ëŠ”ë°, "# output pages"ëŠ” R, Sì— ëŒ€í•˜ì—¬ ê³ ì •ê°’ì´ê¸° ë•Œë¬¸ì— Cost ë¹„êµì— ì˜í–¥ì„ ë¼ì¹˜ì§€ ì•Šì•„ì„œ ê³¼ê°íˆ ë¬´ì‹œí•œë‹¤.

#### Block Nested Loops Join (Best)
$$M+N*\lceil (M/(B-2)) \rceil$$

![image](https://user-images.githubusercontent.com/39285147/202917539-30815931-32d8-4d77-aa65-50c25f9b9078.png)

- 1) add $$<r, s>$$ to result
- 2) read next R-block, scan S, etc.

inner ê´€ê³„ Së¥¼ ìŠ¤ìº”í•˜ê¸° ìœ„í•´, í•œ í˜ì´ì§€ë¥¼ input buffer, ë‹¤ë¥¸ í•œ í˜ì´ì§€ë¥¼ output buffer, ë‚˜ë¨¸ì§€ í˜ì´ì§€ë“¤ì„ outer Rì˜ "block" ì €ì¥ì†Œë¡œ ì‚¬ìš©í•œë‹¤.

- Rì´ í•œ ë²ˆ ìŠ¤ìº”ë  ë•Œ, $$cost = M$$ pages
- ê° block ì‚¬ì´ì¦ˆ = $$(B-2)$$ ($$B$$ = # of buffer pages)
    - S ì½ëŠ” íšŸìˆ˜ = $$\lceil (M/(B-2)) \rceil$$.
- ì´ ë¹„ìš©: $$M+N*\lceil (M/(B-2)) \rceil$$.

##### Examples of Block Nested Loops
**ë¹„ìš©: Scan of outer +  #outer blocks * scan of inner**
- $$\#\ outer\ blocks = \lceil (\#\ of\ pages\ of\ outer\ /\ blocksize) \rceil$$.

Reserves (R) = outer | í•œ ë²ˆì— 100 pages of R ì¡°íšŒ ê°€ëŠ¥:
- R ìŠ¤ìº” ë¹„ìš© = 1000 I/Os; a total of 10 blocks (1000 / 100).
- Per block of R, S ìŠ¤ìº” íšŸìˆ˜ = 10*500 I/Os.

> ë§Œì•½ í•œ ë²ˆì— R ìŠ¤ìº” 90 pages ê°€ëŠ¥ $$\rightarrow$$ S ìŠ¤ìº” íšŸìˆ˜ = 12.
>
>> 90 * 12 = 1080; R í˜ì´ì§€ ê°œìˆ˜ = 1000ê°œ

S = outer with 100-page block:
- S ìŠ¤ìº” ë¹„ìš© = 500 I/Os; a total of 5 blocks.
- Per block of S, R ìŠ¤ìº” íšŸìˆ˜ = 5*1000 I/Os.

#### ìµœì í™” (Minimization)â˜…â˜…â˜…
- 1) í¬ê¸°ê°€ ì‘ì€ relation, Së¥¼ outerë¡œ ì§€ì •í•˜ë©´ ë¹„ìš©ì´ ê°ì†Œ; $$Cost\ =\ 500 + 500*1000$$ 
- 2) tuple ëŒ€ì‹  block ë‹¨ìœ„(= page ë‹¨ìœ„)ë¡œ JOIN êµ¬í˜„í•´ì•¼ ë¹„ìš©ì´ ê°ì†Œ
- 3) bufferë¥¼ ìµœëŒ€ í™œìš©í•œë‹¤; ë¹ˆê³µê°„ ì—†ë„ë¡!
    - outer pagesë¡œ ë©”ëª¨ë¦¬ ë¹ˆê³µê°„ ì±„ì›€ $$\rightarrow$$ Cost ê°ì†Œ!!

### 2) Sort-merge join $$R \infty S$$.
$$Cost: 5(M+N) = 4(M+N)+(M+N)$$

![image](https://user-images.githubusercontent.com/39285147/202923587-893b7267-110e-408e-953d-3a75dd4ddb5e.png)

R, Sì— ëŒ€í•˜ì—¬ JOIN ì´í›„, join col ê¸°ì¤€ìœ¼ë¡œ merge ìˆ˜í–‰

![image](https://user-images.githubusercontent.com/39285147/202920782-0819099c-0a12-4cf1-a374-5878dcb8551a.png)

- 1) R ìŠ¤ìº” until R-tuple $$>=$$ í˜„ì¬ S-tuple 
- 2) S ìŠ¤ìº” until S-tuple $$>=$$ í˜„ì¬ R-tuple
- 3) ì¢…ë£Œ until í˜„ì¬ R-tuple $$=$$ í˜„ì¬ S-tuple
    - ì´ ì‹œì ì—ì„œ, Ri-tuple = Sj-tuple (ë§¤ì¹­)
- 4) output $$<r,s>$$.
- 5) R, S ìŠ¤ìº” ì¬ê°œ

R ìŠ¤ìº” í•œ ë²ˆ = ê° S group ìŠ¤ìº” í•œ ë²ˆ (per matching R tuple)
- ì—¬ëŸ¬ ë²ˆì˜ S group ìŠ¤ìº” $$\rightarrow$$ bufferì—ì„œ ëŒ€ìƒ í˜ì´ì§€ íƒìƒ‰ ê°€ëŠ¥ì„± â†‘

![image](https://user-images.githubusercontent.com/39285147/202918454-f5bbd1b3-0171-4b9b-8a7f-4e3b60493ac0.png)

ìƒê¸° í…Œì´ë¸”ì€ í¬ê¸°ê°€ ë” í° í…Œì´ë¸”ì´ outerì´ë¯€ë¡œ, costê°€ ë¹„íš¨ìœ¨ì ì´ë‹ˆ, ìˆœì„œë¥¼ ë°”ê¾¸ì.

![image](https://user-images.githubusercontent.com/39285147/202922830-1514c952-7650-4190-b3e2-d4a2351e159c.png)

$$Cost: 5(M+N) = 4(M+N)+(M+N)$$

ìƒê¸° ê³µì‹ì€ í•­ìƒ ì˜³ì§€ ì•Šë‹¤. ì™œëƒí•˜ë©´, ìŠ¤ìº” ë¹„ìš©($$M+N$$)ì€ ë“œë¬¼ê²Œ $$M*N(worse\ case)$$ì´ ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

> Worst-case: ìƒê¸° ì‚¬ì§„ ì•„ë˜ ë¶€ë¶„, ëª¨ë“  tupleë“¤ì´ identical í•œ ê²½ìš°

ì¼ë°˜ ê²½ìš°ì—ì„œ, 100 buffer pagesë¥¼ ì‚¬ìš©í•˜ì—¬ R, SëŠ” *2 passes* ì•ˆì— ì •ë ¬ë  ìˆ˜ ìˆë‹¤.

$$total\ join\ cost = 4(500+1000)+1000+500=7500$$.

> ì°¸ê³ , [$$ìµœëŒ€ Cost\ =\ 4(M + N)\ (most\ cases);\ where\ M,\ N<=B^2$$](#ì¼ë°˜í™”)
>> í•˜ì§€ë§Œ, relations R, Sê°€ ì •ë ¬ëœ ìƒíƒœë¼ë©´ í•´ë‹¹ ê²½ìš°ëŠ” ê³ ë ¤í•˜ì§€ ì•Šì•„ë„ ë¬´ë°©í•˜ë‹¤.

> ë©”ëª¨ë¦¬ì— ëª¨ë‘ í•œ ë²ˆì— ë„£ì„ ìˆ˜ ìˆë‹¤ë©´ (= memory â†‘, table â†“), $$Cost=M+N$$.

### 3) Hash join
> hash-join **ë™ì‘ì›ë¦¬** ì‹œê°í™” ê¸°ë§ê³ ì‚¬ ì¶œì œ â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…

$$Cost = 3(M+N) = 2(M+N)+(M+N)$$

- partition: $$2(M+N)$$; read+write
- read both relations(**h2** í•¨ìˆ˜): $$(M+N)$$

#### ì§ê´€
![image](https://user-images.githubusercontent.com/39285147/202923605-4d876eaa-85a3-401a-9832-cd9c8d541f0c.png)

ë‚¨ì ì¹´í…Œê³ ë¦¬ì—ì„œ ë¨¼ì € ì„±ì„ ê¸°ì¤€ìœ¼ë¡œ JOINí•˜ì—¬ partitionì„ í˜•ì„±í•˜ê³ , ì´í›„ partitionsë“¤ì„ ì—¬ì ì¹´í…Œê³ ë¦¬ì™€ JOINì„ ìˆ˜í–‰.

![image](https://user-images.githubusercontent.com/39285147/203171633-c33f8be4-a94e-422b-a2d5-28e7bba47cd2.png)

- hash í•¨ìˆ˜ **h**ë¥¼ ì‚¬ìš©í•˜ì—¬ R, S partition ê°ê° í˜•ì„±
- partition iì˜ R tuplesì€ *ì˜¤ë¡œì§€* S tuples in partition iê³¼ ë§¤ì¹­
- hash í•¨ìˆ˜ **h2**ë¥¼ ì‚¬ìš©í•˜ì—¬ partition of Rê³¼ partition of Së¥¼ ë§¤ì¹­

#### ë™ì‘ì›ë¦¬
![image](https://user-images.githubusercontent.com/39285147/203170956-9d2e1f5e-4a17-47dd-9574-1cc00294e91a.png)

- 4í¬ê¸°ì˜ ë©”ëª¨ë¦¬: 1ê°œë¥¼ INPUT, ë‚˜ë¨¸ì§€ 3ê°œë¥¼ buffer pages
- ***ì§ê´€*** íŒŒíŠ¸ì—ì„œ ë³¸ ë‚¨ìëŠ” R, ì—¬ìëŠ” Sê³¼ ë§¤ì¹­
- í•´ì‰¬ í•¨ìˆ˜ **h**: R, S JOIN ìˆ˜í–‰
- í•´ì‰¬ í•¨ìˆ˜ **h2**: R, Sì˜ ê° ëŒ€ì‘í•˜ëŠ” partition JOIN ìˆ˜í–‰

1) R, S í•´ì‰¬ í•¨ìˆ˜(**h**) JOIN
$$\#\ partition ={M \over B-1},\ where\ -1\ for\ input\ buffer\ page$$
2) ë§¤ì¹­ë˜ëŠ” partitionë¼ë¦¬ í•´ì‰¬ í•¨ìˆ˜(**h2**) JOIN
$${M \over B-1} < B-2,\ where\ -2\ for\ input/output\ buffer\ pages$$
$$M<(B-1)(B-2) \approx B^2$$
3) JOIN ê²°ê³¼ output

### 4) Index Nested Loop Join
        foreach tuple r in R do
            foreach tuple s in S where ri == sj  do
                add <r, s> to result

ë§Œì•½ inner tableì—ì„œ í•œ relationì—ì„œ JOINë˜ëŠ” columnì˜ indexë¥¼ ì•ˆë‹¤ë©´, í•´ë‹¹ relation ì „ì²´ tuples íƒìƒ‰ì´ ì•„ë‹ˆë¼, í•´ë‹¹ ì¸ë±ìŠ¤ê¹Œì§€ë§Œ ë¹„ìš© ê³„ì‚°í•˜ë©´ ë  ê²ƒì´ë‹¤.

![image](https://user-images.githubusercontent.com/39285147/203175032-fe03dd80-e92a-4e14-b30d-54fdd45eeb7d.png)

ê°€ë ¹, ìƒê¸° ê·¸ë¦¼ì—ì„œ í˜„ì¬ íƒ€ê²Ÿ = 20 $$\rightarrow$$ inner tableì—ì„œ ì¸ë±ìŠ¤ 20ë§Œ ë¹ ë¥´ê²Œ ì¡°íšŒ

ê° R tupleì— ëŒ€í•˜ì—¬, S index íƒìƒ‰ ë¹„ìš©:
- *hash index*: 1.2
- *B+ tree*: [2, 4]

> Index Nest Loop Joinì—ì„œ Cost ê³„ì‚°ì€ ê¸°ë§ ì•ˆ ë‚˜ì˜´!
>
>> $$Cost:  M + ( (M*pR) * cost\ of\ finding\ matching\ S\ tuples)$$.
>>
>> *Clustered index*: 1 I/O (typical)
>>
>> *Unclustered*: up to 1 I/O per matching S tuple.

****
# Clustered vs Unclustered
![image](https://user-images.githubusercontent.com/39285147/207963371-26d9e250-7058-449b-9c37-9ca0ceb7ad9c.png)

## Clustered Index
            Cluster : êµ°ì§‘
            Clustered : êµ°ì§‘í™”
            Clustered Index : êµ°ì§‘í™” ëœ ì¸ë±ìŠ¤

[*id = Clustered index*]

![image](https://user-images.githubusercontent.com/39285147/207962315-0191e8c3-14e9-4dbd-87aa-b4a7874c8165.png)

- í…Œì´ë¸” ë‹¹ í•˜ë‚˜ì˜ Clustered index
- ê²€ìƒ‰ ì†ë„ â†‘, ë°ì´í„° ì‚½ì… ë¹„ìš© â†‘
- ë°ì´í„° ë¬¼ë¦¬ì  ì €ì¥ ìˆœì„œ ì •ì˜
    - íŠ¹ì • ì»¬ëŸ¼ì„ ê¸°ì¤€ ë°ì´í„° ì •ë ¬

![image](https://user-images.githubusercontent.com/39285147/207961904-71f5f262-1e08-44eb-9513-09c059d56d86.png)

## Unclustered Index
            NonCluster : ë¹„ êµ°ì§‘
            NonClustered : ë¹„ êµ°ì§‘í™”
            NonClustered Index: êµ°ì§‘í™”ë˜ì–´ ìˆì§€ ì•Šì€ ì¸ë±ìŠ¤

![image](https://user-images.githubusercontent.com/39285147/207961940-0d8b4d12-7f63-4031-8ce6-294b302df622.png)

- í…Œì´ë¸” ë‹¹ ì—¬ëŸ¬ê°œ unclustered index
- Unclustered index í…Œì´ë¸” ì €ì¥ X, ë³„ë„ì˜ ì¥ì†Œì— ì €ì¥
- í…Œì´ë¸”ì˜ ë¬¼ë¦¬ì ì¸ ìˆœì„œì— ë”°ë¼ ë°ì´í„° ì •ë ¬
    - ìˆœì„œëŒ€ë¡œ ì •ë ¬ X

****
# Summary âœ”
- Join = very common, but very expensive
- ë¹„ìŠ·í•œ tuples ë§¤ì¹­ í•„ìš”
    - sort
    - hash
    - using an index
    - just enumerate all pairs (nested loop joins)

****
# Reference 
[Database Management Systems by Raghu Ramakrishnan and Johannes Gehrke](https://pages.cs.wisc.edu/~dbbook/)

[Relational Operators](https://www.javatpoint.com/dbms-relational-algebra)